var widgets = require('@jupyter-widgets/base');
var _ = require('lodash');
var d3 = require('d3');
const { sum } = require('lodash');

// See example.py for the kernel counterpart to this file.


// Custom Model. Custom widgets models must at least provide default values
// for model attributes, including
//
//  - `_view_name`
//  - `_view_module`
//  - `_view_module_version`
//
//  - `_model_name`
//  - `_model_module`
//  - `_model_module_version`
//
//  when different from the base class.

// When serialiazing the entire widget state for embedding, only values that
// differ from the defaults will be specified.
var HelloModel = widgets.DOMWidgetModel.extend({
    defaults: _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
        _model_name: 'HelloModel',
        _view_name: 'HelloView',
        _model_module: 'ToCController',
        _view_module: 'ToCController',
        _model_module_version: '0.1.0',
        _view_module_version: '0.1.0',
        summaries: '{}',
        dag: '[]',
        attentionRequests: '{}'
    })
});


// Custom View. Renders the widget model.
var HelloView = widgets.DOMWidgetView.extend({
    // Defines how the widget gets rendered into the DOM
    render: function () {
        // Observe changes in the value traitlet in Python, and define
        // a custom callback.
        this.el.textContent = "ToC Supported: " + this.tocSupported;
        console.log('WOW 16');
    },
    initialize: function () {
        console.log("INITIALIZE");
        //
        this.tocSupported = Boolean(d3.select('#toc-wrapper').node());

        //
        if (!d3.dagStratify) {
            importDag();
        }

        //
        this._attRequests = {};
        this.selectedWidget = undefined;

        //
        if (!window.dagController)
            window.dagController = this;

        //
        this.model.on('change:dag', this.dag_changed, this);
        this.model.on('change:attentionRequests', this.attentionRequests, this);
        this.model.on('change:summaries', this.summariesChanged, this);
    },
    fillDetails: function (_id) {
        //only work if supported
        if (!this.tocSupported)
            return;

        //
        d3.select('#detailsNameLabel').text(_id);
        var summaries = JSON.parse(this.model.get('summaries'));
        if (_id in summaries) {
            //
            var summary = summaries[_id];
            d3.select('#detailsProgressBar')
                .style('height', '100%')
                .style('width', summary['progress'] + '%')
                .text(summary['progress'] + '%');
        }
        else {
            console.log('missing sumamries', summaries);
        }
        //
        //
        var attentionRequests = JSON.parse(this.model.get('attentionRequests'));
        var mapTypeID = { "RESCALE_NEEDED": "attAxesLabel", "PROGRESS_NOTIFICATION": "attProgressLabel", "STABILITY_REACHED": "attStabilityLabel", "SAFEGUARD_SATISFIED": "attSafeguardLabel" };

        //if there is at least one attention request for _id
        if (_id in attentionRequests) {
            var attRequests = attentionRequests[_id];
            for (var key in mapTypeID) {
                var description = "";
                if ((key in attRequests) && ('description' in attRequests[key]))
                    description = attRequests[key]['description'];
                var labelID = mapTypeID[key];
                d3.select("#" + labelID)
                    .text(description);
            }
        }
        //if _id is not in attentionRequest and selected 
        //this means that there is no attention request left
        //and so we need to update the interface
        else if (this.selectedWidget == _id) {
            for (var key in mapTypeID) {
                var labelID = mapTypeID[key];
                d3.select("#" + labelID)
                    .text("");
            }
        }
    },
    summariesChanged: function () {
        //only work if supported
        if (!this.tocSupported)
            return;

        if (this.selectedWidget) {
            this.fillDetails(this.selectedWidget);
        }
    },
    dag_changed: function () {
        //only work if supported
        if (!this.tocSupported)
            return;
        //
        var info = JSON.parse(this.model.get('dag'));
        var _dag = info.dag;

        //clear dag view        
        const edgeGroup = d3.select('#dagCanvas').select('#edgeGroup').node()
            ? d3.select('#dagCanvas').select('#edgeGroup')
            : d3.select('#dagCanvas').append('g')
                .attr('id', 'edgeGroup');
        edgeGroup.selectAll('*').remove();


        const nodeGroup = d3.select('#dagCanvas').select('#nodeGroup').node()
            ? d3.select('#dagCanvas').select('#nodeGroup')
            : d3.select('#dagCanvas').append('g')
                .attr('id', 'nodeGroup');
        nodeGroup.selectAll('*').remove();
        //
        if (_dag.length == 0) {
            //
            return;
        }
        //
        const dag = d3.dagStratify()(_dag);
        const nodeRadius = 20;
        const layout = d3
            .sugiyama() // base layout
            .decross(d3.decrossOpt()) // minimize number of crossings
            .nodeSize((node) => [(node ? 3.6 : 0.25) * nodeRadius, 3 * nodeRadius]); // set node size instead of constraining to fit
        const { width, height } = layout(dag);

        const line = d3
            .line()
            .curve(d3.curveCatmullRom)
            .x((d) => d.x)
            .y((d) => d.y);

        // Plot edges        
        edgeGroup
            .selectAll("path")
            .data(dag.links())
            .join("path")
            .attr("d", ({ points }) => line(points))
            .attr('id', d => 'eS' + d.source.data.id + 'T' + d.target.data.id)
            .attr("fill", "none")
            .attr("stroke-width", 3)
            .attr("stroke", 'black');
        //plot nodes
        nodeGroup.style('cursor', 'pointer');
        var that = this;
        const nodes = nodeGroup
            .selectAll("g")
            .data(dag.descendants())
            .enter()
            .append("g")
            .attr('id', d => 'gnD' + d.data.id)
            .attr("transform", ({ x, y }) => `translate(${x}, ${y})`)
            .on('mouseover', function () {
                d3.select(this).select('circle').attr('stroke-width', 5);
            })
            .on('mouseout', function () {
                d3.select(this).select('circle').attr('stroke-width', 1);
            })
            .on('click', function () {
                var label = d3.select(this).select('circle').attr('id').slice(2);
                that.selectedWidget = label;
                var elt = info.dag.find(d => d.id == label);
                //
                d3.select('#widgetNameForm').text(label);
                if (elt) {
                    document.getElementById(elt.divID).scrollIntoView();
                }
                //
                that.fillDetails(label);
            });

        // Plot node circles
        nodes
            .append("circle")
            .attr('id', d => 'nD' + d.data.id)
            .attr("r", nodeRadius)
            .attr("fill", 'white')
            .attr("stroke", 'black');

        // Add text to nodes
        nodes
            .append("text")
            .text((d) => d.data.id)
            .attr("font-weight", "bold")
            .attr("font-family", "sans-serif")
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("fill", "black");
    },
    userRemoveAttRqs: function (_id, type) {
        //only work if supported
        if (!this.tocSupported)
            return;
        //
        var attRequests = JSON.parse(this.model.get('attentionRequests'));
        console.log(attRequests, _id, type);
        //this should always be true, since this is only called by the toc interface
        //with the right _id parameter
        if (_id == this.selectedWidget && _id in attRequests) {
            // if (type in attRequests[_id]) {
            //     delete attRequests[_id][type]
            //     if (Object.keys(attRequests[_id]).length == 0)
            //         delete attRequests[_id];
            //     this.model.set('attentionRequests', JSON.stringify(attRequests));
            //     console.log('SETANDO', attRequests);
            // }
            console.log('SETTING OPERATION');
            this.model.set('interfaceOperations', "REMOVER");
        }

    },
    attentionRequests: function () {
        //only work if supported
        if (!this.tocSupported)
            return;
        //{'entityType':entityType,'widgetID':internalID,'type':eventType,'description':description}
        var newAttentionOperation = JSON.parse(this.model.get('attentionRequests'));
        if (newAttentionOperation['op'] == 'add') {
            if (!(newAttentionOperation['widgetID'] in this._attRqs)) {
                this._attRqs[internalID] = {}
            }
            this._attRqs[newAttentionOperation['widgetID']][newAttentionOperation['type']] = newAttentionOperation;
        }
        else if (newAttentionOperation['op'] == 'remove') {
            //
            var internalID = newAttentionOperation['widgetID'];
            var eventType = newAttentionOperation['type'];
            if ((internalID in this._attRqs) &&
                (eventType in self._attRqs[internalID])) {
                delete this._attRqs[internalID][eventType]
            }

            if ((internalID in this._attRqs) &&
                (Object.keys(this._attRqs[internalID]).length == 0)) {
                delete this._attRqs[internalID];
            }
        }

        //
        var attentionRequests = this._attRqs;
        var colorScale =
            d3.scaleOrdinal().domain(["RESCALE_NEEDED", "PROGRESS_NOTIFICATION", "STABILITY_REACHED", "SAFEGUARD_SATISFIED"]).range(['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4']);

        //console.log("Attention Request", attentionRequests);
        var that = this;
        //TODO: CHANGE STROKE FOR SHOWING THAT THERE IS MORE THAN
        //ONE ATTENTION REQUEST
        d3.select('#nodeGroup')
            .selectAll('circle')
            .attr('stroke-dasharray', function () {
                var _id = d3.select(this).attr("id").slice(2);
                if (_id in attentionRequests) {
                    var attRequests = attentionRequests[_id];
                    var numRequests = Object.keys(attRequests).length;
                    if (numRequests > 1) {
                        return "4";
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            })
            .attr('fill', function () {
                var _id = d3.select(this).attr("id").slice(2);

                if (that.selectedWidget == _id) {
                    that.fillDetails(_id);
                }

                if (_id in attentionRequests) {
                    var attRequests = attentionRequests[_id];
                    //
                    var attRequest = undefined;
                    var requestTypes = colorScale.domain();
                    for (var index in requestTypes) {
                        var key = requestTypes[index];
                        if (key in attRequests) {
                            attRequest = attRequests[key];
                            break;
                        }
                    }
                    //
                    var color = colorScale(attRequest.type);
                    return color;
                }
                else {
                    return 'white';
                }
            });
    }
});

module.exports = {
    HelloModel: HelloModel,
    HelloView: HelloView
};

function importDag() {
    d3 = Object.assign(d3 || {}, (() => {
        var d3 = (() => {
            var ro = Object.create; var Me = Object.defineProperty; var no = Object.getOwnPropertyDescriptor; var oo = Object.getOwnPropertyNames; var io = Object.getPrototypeOf, ao = Object.prototype.hasOwnProperty; var V = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), so = (e, t) => { for (var r in t) Me(e, r, { get: t[r], enumerable: !0 }) }, Jt = (e, t, r, n) => { if (t && typeof t == "object" || typeof t == "function") for (let o of oo(t)) !ao.call(e, o) && o !== r && Me(e, o, { get: () => t[o], enumerable: !(n = no(t, o)) || n.enumerable }); return e }; var ze = (e, t, r) => (r = e != null ? ro(io(e)) : {}, Jt(t || !e || !e.__esModule ? Me(r, "default", { value: e, enumerable: !0 }) : r, e)), uo = e => Jt(Me({}, "__esModule", { value: !0 }), e); var mt = V((Wi, tr) => { "use strict"; var lo = function (e, t) { return e < t }; function _(e) { if (!(this instanceof _)) return new _(e); this.array = [], this.size = 0, this.compare = e || lo } _.prototype.clone = function () { var e = new _(this.compare); return e.size = this.size, e.array = this.array.slice(0, this.size), e }; _.prototype.add = function (e) { var t = this.size; this.array[this.size] = e, this.size += 1; for (var r, n; t > 0 && (r = t - 1 >> 1, n = this.array[r], !!this.compare(e, n));)this.array[t] = n, t = r; this.array[t] = e }; _.prototype.heapify = function (e) { this.array = e, this.size = e.length; var t; for (t = this.size >> 1; t >= 0; t--)this._percolateDown(t) }; _.prototype._percolateUp = function (e, t) { for (var r = this.array[e], n, o; e > 0 && (n = e - 1 >> 1, o = this.array[n], !(!t && !this.compare(r, o)));)this.array[e] = o, e = n; this.array[e] = r }; _.prototype._percolateDown = function (e) { for (var t = this.size, r = this.size >>> 1, n = this.array[e], o, a, i; e < r && (o = (e << 1) + 1, a = o + 1, i = this.array[o], a < t && this.compare(this.array[a], i) && (o = a, i = this.array[a]), !!this.compare(i, n));)this.array[e] = i, e = o; this.array[e] = n }; _.prototype._removeAt = function (e) { if (!(e > this.size - 1 || e < 0)) return this._percolateUp(e, !0), this.poll() }; _.prototype.remove = function (e) { for (var t = 0; t < this.size; t++)if (!this.compare(this.array[t], e) && !this.compare(e, this.array[t])) return this._removeAt(t), !0; return !1 }; _.prototype.removeOne = function (e) { if (typeof e == "function") { for (var t = 0; t < this.size; t++)if (e(this.array[t])) return this._removeAt(t) } }; _.prototype.removeMany = function (e, t) { if (typeof e != "function" || this.size < 1) return []; t = t ? Math.min(t, this.size) : this.size; for (var r = 0, n = new Array(t), o = 0, a = new Array(this.size); r < t && !this.isEmpty();) { var i = this.poll(); e(i) ? n[r++] = i : a[o++] = i } n.length = r; for (var s = 0; s < o;)this.add(a[s++]); return n }; _.prototype.peek = function () { if (this.size != 0) return this.array[0] }; _.prototype.poll = function () { if (this.size != 0) { var e = this.array[0]; return this.size > 1 ? (this.array[0] = this.array[--this.size], this._percolateDown(0)) : this.size -= 1, e } }; _.prototype.replaceTop = function (e) { if (this.size != 0) { var t = this.array[0]; return this.array[0] = e, this._percolateDown(0), t } }; _.prototype.trim = function () { this.array = this.array.slice(0, this.size) }; _.prototype.isEmpty = function () { return this.size === 0 }; _.prototype.forEach = function (e) { if (!(this.isEmpty() || typeof e != "function")) for (var t = 0, r = this.clone(); !r.isEmpty();)e(r.poll(), t++) }; _.prototype.kSmallest = function (e) { if (this.size == 0) return []; e = Math.min(this.size, e); var t = new _(this.compare); let r = Math.min((e > 0 ? Math.pow(2, e - 1) : 0) + 1, this.size); t.size = r, t.array = this.array.slice(0, r); for (var n = new Array(e), o = 0; o < e; o++)n[o] = t.poll(); return n }; tr.exports = _ }); var Dt = V((Xd, Nr) => { function xr(e, t, r, n) { this.feasible = r, this.evaluation = t, this.bounded = n, this._tableau = e } Nr.exports = xr; xr.prototype.generateSolutionSet = function () { for (var e = {}, t = this._tableau, r = t.varIndexByRow, n = t.variablesPerIndex, o = t.matrix, a = t.rhsColumn, i = t.height - 1, s = Math.round(1 / t.precision), u = 1; u <= i; u += 1) { var l = r[u], d = n[l]; if (!(d === void 0 || d.isSlack === !0)) { var f = o[u][a]; e[d.id] = Math.round((Number.EPSILON + f) * s) / s } } return e } }); var br = V((ef, yr) => { var vr = Dt(); function Ge(e, t, r, n, o) { vr.call(this, e, t, r, n), this.iter = o } yr.exports = Ge; Ge.prototype = Object.create(vr.prototype); Ge.constructor = Ge }); var Q = V((tf, Or) => { var Xo = Dt(), ei = br(); function K(e) { this.model = null, this.matrix = null, this.width = 0, this.height = 0, this.costRowIndex = 0, this.rhsColumn = 0, this.variablesPerIndex = [], this.unrestrictedVars = null, this.feasible = !0, this.evaluation = 0, this.simplexIters = 0, this.varIndexByRow = null, this.varIndexByCol = null, this.rowByVarIndex = null, this.colByVarIndex = null, this.precision = e || 1e-8, this.optionalObjectives = [], this.objectivesByPriority = {}, this.savedState = null, this.availableIndexes = [], this.lastElementIndex = 0, this.variables = null, this.nVars = 0, this.bounded = !0, this.unboundedVarIndex = null, this.branchAndCutIterations = 0 } Or.exports = K; K.prototype.solve = function () { return this.model.getNumberOfIntegerVariables() > 0 ? this.branchAndCut() : this.simplex(), this.updateVariableValues(), this.getSolution() }; function St(e, t) { this.priority = e, this.reducedCosts = new Array(t); for (var r = 0; r < t; r += 1)this.reducedCosts[r] = 0 } St.prototype.copy = function () { var e = new St(this.priority, this.reducedCosts.length); return e.reducedCosts = this.reducedCosts.slice(), e }; K.prototype.setOptionalObjective = function (e, t, r) { var n = this.objectivesByPriority[e]; if (n === void 0) { var o = Math.max(this.width, t + 1); n = new St(e, o), this.objectivesByPriority[e] = n, this.optionalObjectives.push(n), this.optionalObjectives.sort(function (a, i) { return a.priority - i.priority }) } n.reducedCosts[t] = r }; K.prototype.initialize = function (e, t, r, n) { this.variables = r, this.unrestrictedVars = n, this.width = e, this.height = t; for (var o = new Array(e), a = 0; a < e; a++)o[a] = 0; this.matrix = new Array(t); for (var i = 0; i < t; i++)this.matrix[i] = o.slice(); this.varIndexByRow = new Array(this.height), this.varIndexByCol = new Array(this.width), this.varIndexByRow[0] = -1, this.varIndexByCol[0] = -1, this.nVars = e + t - 2, this.rowByVarIndex = new Array(this.nVars), this.colByVarIndex = new Array(this.nVars), this.lastElementIndex = this.nVars }; K.prototype._resetMatrix = function () { var e = this.model.variables, t = this.model.constraints, r = e.length, n = t.length, o, a, i = this.matrix[0], s = this.model.isMinimization === !0 ? -1 : 1; for (o = 0; o < r; o += 1) { var u = e[o], l = u.priority, d = s * u.cost; l === 0 ? i[o + 1] = d : this.setOptionalObjective(l, o + 1, d), a = e[o].index, this.rowByVarIndex[a] = -1, this.colByVarIndex[a] = o + 1, this.varIndexByCol[o + 1] = a } for (var f = 1, h = 0; h < n; h += 1) { var m = t[h], p = m.index; this.rowByVarIndex[p] = f, this.colByVarIndex[p] = -1, this.varIndexByRow[f] = p; var c, x, N, v = m.terms, b = v.length, y = this.matrix[f++]; if (m.isUpperBound) { for (c = 0; c < b; c += 1)x = v[c], N = this.colByVarIndex[x.variable.index], y[N] = x.coefficient; y[0] = m.rhs } else { for (c = 0; c < b; c += 1)x = v[c], N = this.colByVarIndex[x.variable.index], y[N] = -x.coefficient; y[0] = -m.rhs } } }; K.prototype.setModel = function (e) { this.model = e; var t = e.nVariables + 1, r = e.nConstraints + 1; return this.initialize(t, r, e.variables, e.unrestrictedVariables), this._resetMatrix(), this }; K.prototype.getNewElementIndex = function () { if (this.availableIndexes.length > 0) return this.availableIndexes.pop(); var e = this.lastElementIndex; return this.lastElementIndex += 1, e }; K.prototype.density = function () { for (var e = 0, t = this.matrix, r = 0; r < this.height; r++)for (var n = t[r], o = 0; o < this.width; o++)n[o] !== 0 && (e += 1); return e / (this.height * this.width) }; K.prototype.setEvaluation = function () { var e = Math.round(1 / this.precision), t = this.matrix[this.costRowIndex][this.rhsColumn], r = Math.round((Number.EPSILON + t) * e) / e; this.evaluation = r, this.simplexIters === 0 && (this.bestPossibleEval = r) }; K.prototype.getSolution = function () { var e = this.model.isMinimization === !0 ? this.evaluation : -this.evaluation; return this.model.getNumberOfIntegerVariables() > 0 ? new ei(this, e, this.feasible, this.bounded, this.branchAndCutIterations) : new Xo(this, e, this.feasible, this.bounded) } }); var wr = V(() => { var Le = Q(); Le.prototype.simplex = function () { return this.bounded = !0, this.phase1(), this.feasible === !0 && this.phase2(), this }; Le.prototype.phase1 = function () { for (var e = this.model.checkForCycles, t = [], r = this.matrix, n = this.rhsColumn, o = this.width - 1, a = this.height - 1, i, s = 0; ;) { for (var u = 0, l = -this.precision, d = 1; d <= a; d++) { i = this.unrestrictedVars[this.varIndexByRow[d]] === !0; var f = r[d][n]; f < l && (l = f, u = d) } if (u === 0) return this.feasible = !0, s; for (var h = 0, m = -1 / 0, p = r[0], c = r[u], x = 1; x <= o; x++) { var N = c[x]; if (i = this.unrestrictedVars[this.varIndexByCol[x]] === !0, i || N < -this.precision) { var v = -p[x] / N; m < v && (m = v, h = x) } } if (h === 0) return this.feasible = !1, s; if (e) { t.push([this.varIndexByRow[u], this.varIndexByCol[h]]); var b = this.checkForCycles(t); if (b.length > 0) return this.model.messages.push("Cycle in phase 1"), this.model.messages.push("Start :" + b[0]), this.model.messages.push("Length :" + b[1]), this.feasible = !1, s } this.pivot(u, h), s += 1 } }; Le.prototype.phase2 = function () { for (var e = this.model.checkForCycles, t = [], r = this.matrix, n = this.rhsColumn, o = this.width - 1, a = this.height - 1, i = this.precision, s = this.optionalObjectives.length, u = null, l = 0, d, f; ;) { var h = r[this.costRowIndex]; s > 0 && (u = []); for (var m = 0, p = i, c = !1, x = 1; x <= o; x++) { if (d = h[x], f = this.unrestrictedVars[this.varIndexByCol[x]] === !0, s > 0 && -i < d && d < i) { u.push(x); continue } if (f && d < 0) { -d > p && (p = -d, m = x, c = !0); continue } d > p && (p = d, m = x, c = !1) } if (s > 0) for (var N = 0; m === 0 && u.length > 0 && N < s;) { var v = [], b = this.optionalObjectives[N].reducedCosts; p = i; for (var y = 0; y < u.length; y++) { if (x = u[y], d = b[x], f = this.unrestrictedVars[this.varIndexByCol[x]] === !0, -i < d && d < i) { v.push(x); continue } if (f && d < 0) { -d > p && (p = -d, m = x, c = !0); continue } d > p && (p = d, m = x, c = !1) } u = v, N += 1 } if (m === 0) return this.setEvaluation(), this.simplexIters += 1, l; for (var w = 0, D = 1 / 0, L = this.varIndexByRow, O = 1; O <= a; O++) { var S = r[O], C = S[n], k = S[m]; if (!(-i < k && k < i)) { if (k > 0 && i > C && C > -i) { D = 0, w = O; break } var M = c ? -C / k : C / k; M > i && D > M && (D = M, w = O) } } if (D === 1 / 0) return this.evaluation = -1 / 0, this.bounded = !1, this.unboundedVarIndex = this.varIndexByCol[m], l; if (e) { t.push([this.varIndexByRow[w], this.varIndexByCol[m]]); var A = this.checkForCycles(t); if (A.length > 0) return this.model.messages.push("Cycle in phase 2"), this.model.messages.push("Start :" + A[0]), this.model.messages.push("Length :" + A[1]), this.feasible = !1, l } this.pivot(w, m, !0), l += 1 } }; var Lt = []; Le.prototype.pivot = function (e, t) { var r = this.matrix, n = r[e][t], o = this.height - 1, a = this.width - 1, i = this.varIndexByRow[e], s = this.varIndexByCol[t]; this.varIndexByRow[e] = s, this.varIndexByCol[t] = i, this.rowByVarIndex[s] = e, this.rowByVarIndex[i] = -1, this.colByVarIndex[s] = -1, this.colByVarIndex[i] = t; for (var u = r[e], l = 0, d = 0; d <= a; d++)u[d] >= -1e-16 && u[d] <= 1e-16 ? u[d] = 0 : (u[d] /= n, Lt[l] = d, l += 1); u[t] = 1 / n; for (var f, h, m, p = this.precision, c = 0; c <= o; c++)if (c !== e && !(r[c][t] >= -1e-16 && r[c][t] <= 1e-16)) { var x = r[c]; if (f = x[t], f >= -1e-16 && f <= 1e-16) f !== 0 && (x[t] = 0); else { for (h = 0; h < l; h++)d = Lt[h], m = u[d], m >= -1e-16 && m <= 1e-16 ? m !== 0 && (u[d] = 0) : x[d] = x[d] - f * m; x[t] = -f / n } } var N = this.optionalObjectives.length; if (N > 0) for (var v = 0; v < N; v += 1) { var b = this.optionalObjectives[v].reducedCosts; if (f = b[t], f !== 0) { for (h = 0; h < l; h++)d = Lt[h], m = u[d], m !== 0 && (b[d] = b[d] - f * m); b[t] = -f / n } } }; Le.prototype.checkForCycles = function (e) { for (var t = 0; t < e.length - 1; t++)for (var r = t + 1; r < e.length; r++) { var n = e[t], o = e[r]; if (n[0] === o[0] && n[1] === o[1]) { if (r - t > e.length - r) break; for (var a = !0, i = 1; i < r - t; i++) { var s = e[t + i], u = e[r + i]; if (s[0] !== u[0] || s[1] !== u[1]) { a = !1; break } } if (a) return [t, r - t] } } return [] } }); var qe = V((of, Cr) => { function Ct(e, t, r, n) { this.id = e, this.cost = t, this.index = r, this.value = 0, this.priority = n } function Dr(e, t, r, n) { Ct.call(this, e, t, r, n) } Dr.prototype.isInteger = !0; function It(e, t) { Ct.call(this, e, 0, t, 0) } It.prototype.isSlack = !0; function Sr(e, t) { this.variable = e, this.coefficient = t } function Lr(e, t, r) { return r === 0 || r === "required" ? null : (t = t || 1, r = r || 1, e.isMinimization === !1 && (t = -t), e.addVariable(t, "r" + e.relaxationIndex++, !1, !1, r)) } function ae(e, t, r, n) { this.slack = new It("s" + r, r), this.index = r, this.model = n, this.rhs = e, this.isUpperBound = t, this.terms = [], this.termsByVarIndex = {}, this.relaxation = null } ae.prototype.addTerm = function (e, t) { var r = t.index, n = this.termsByVarIndex[r]; if (n === void 0) n = new Sr(t, e), this.termsByVarIndex[r] = n, this.terms.push(n), this.isUpperBound === !0 && (e = -e), this.model.updateConstraintCoefficient(this, t, e); else { var o = n.coefficient + e; this.setVariableCoefficient(o, t) } return this }; ae.prototype.removeTerm = function (e) { return this }; ae.prototype.setRightHandSide = function (e) { if (e !== this.rhs) { var t = e - this.rhs; this.isUpperBound === !0 && (t = -t), this.rhs = e, this.model.updateRightHandSide(this, t) } return this }; ae.prototype.setVariableCoefficient = function (e, t) { var r = t.index; if (r === -1) { console.warn("[Constraint.setVariableCoefficient] Trying to change coefficient of inexistant variable."); return } var n = this.termsByVarIndex[r]; if (n === void 0) this.addTerm(e, t); else if (e !== n.coefficient) { var o = e - n.coefficient; this.isUpperBound === !0 && (o = -o), n.coefficient = e, this.model.updateConstraintCoefficient(this, t, o) } return this }; ae.prototype.relax = function (e, t) { this.relaxation = Lr(this.model, e, t), this._relax(this.relaxation) }; ae.prototype._relax = function (e) { e !== null && (this.isUpperBound ? this.setVariableCoefficient(-1, e) : this.setVariableCoefficient(1, e)) }; function me(e, t) { this.upperBound = e, this.lowerBound = t, this.model = e.model, this.rhs = e.rhs, this.relaxation = null } me.prototype.isEquality = !0; me.prototype.addTerm = function (e, t) { return this.upperBound.addTerm(e, t), this.lowerBound.addTerm(e, t), this }; me.prototype.removeTerm = function (e) { return this.upperBound.removeTerm(e), this.lowerBound.removeTerm(e), this }; me.prototype.setRightHandSide = function (e) { this.upperBound.setRightHandSide(e), this.lowerBound.setRightHandSide(e), this.rhs = e }; me.prototype.relax = function (e, t) { this.relaxation = Lr(this.model, e, t), this.upperBound.relaxation = this.relaxation, this.upperBound._relax(this.relaxation), this.lowerBound.relaxation = this.relaxation, this.lowerBound._relax(this.relaxation) }; Cr.exports = { Constraint: ae, Variable: Ct, IntegerVariable: Dr, SlackVariable: It, Equality: me, Term: Sr } }); var Ir = V(() => { var Fe = Q(), kt = qe().SlackVariable; Fe.prototype.addCutConstraints = function (e) { for (var t = e.length, r = this.height, n = r + t, o = r; o < n; o += 1)this.matrix[o] === void 0 && (this.matrix[o] = this.matrix[o - 1].slice()); this.height = n, this.nVars = this.width + this.height - 2; for (var a, i = this.width - 1, s = 0; s < t; s += 1) { var u = e[s], l = r + s, d = u.type === "min" ? -1 : 1, f = u.varIndex, h = this.rowByVarIndex[f], m = this.matrix[l]; if (h === -1) { for (m[this.rhsColumn] = d * u.value, a = 1; a <= i; a += 1)m[a] = 0; m[this.colByVarIndex[f]] = d } else { var p = this.matrix[h], c = p[this.rhsColumn]; for (m[this.rhsColumn] = d * (u.value - c), a = 1; a <= i; a += 1)m[a] = -d * p[a] } var x = this.getNewElementIndex(); this.varIndexByRow[l] = x, this.rowByVarIndex[x] = l, this.colByVarIndex[x] = -1, this.variablesPerIndex[x] = new kt("s" + x, x), this.nVars += 1 } }; Fe.prototype._addLowerBoundMIRCut = function (e) { if (e === this.costRowIndex) return !1; var t = this.model, r = this.matrix, n = this.variablesPerIndex[this.varIndexByRow[e]]; if (!n.isInteger) return !1; var o = r[e][this.rhsColumn], a = o - Math.floor(o); if (a < this.precision || 1 - this.precision < a) return !1; var i = this.height; r[i] = r[i - 1].slice(), this.height += 1, this.nVars += 1; var s = this.getNewElementIndex(); this.varIndexByRow[i] = s, this.rowByVarIndex[s] = i, this.colByVarIndex[s] = -1, this.variablesPerIndex[s] = new kt("s" + s, s), r[i][this.rhsColumn] = Math.floor(o); for (var u = 1; u < this.varIndexByCol.length; u += 1) { var l = this.variablesPerIndex[this.varIndexByCol[u]]; if (!l.isInteger) r[i][u] = Math.min(0, r[e][u] / (1 - a)); else { var d = r[e][u], f = Math.floor(d) + Math.max(0, d - Math.floor(d) - a) / (1 - a); r[i][u] = f } } for (var h = 0; h < this.width; h += 1)r[i][h] -= r[e][h]; return !0 }; Fe.prototype._addUpperBoundMIRCut = function (e) { if (e === this.costRowIndex) return !1; var t = this.model, r = this.matrix, n = this.variablesPerIndex[this.varIndexByRow[e]]; if (!n.isInteger) return !1; var o = r[e][this.rhsColumn], a = o - Math.floor(o); if (a < this.precision || 1 - this.precision < a) return !1; var i = this.height; r[i] = r[i - 1].slice(), this.height += 1, this.nVars += 1; var s = this.getNewElementIndex(); this.varIndexByRow[i] = s, this.rowByVarIndex[s] = i, this.colByVarIndex[s] = -1, this.variablesPerIndex[s] = new kt("s" + s, s), r[i][this.rhsColumn] = -a; for (var u = 1; u < this.varIndexByCol.length; u += 1) { var l = this.variablesPerIndex[this.varIndexByCol[u]], d = r[e][u], f = d - Math.floor(d); l.isInteger ? f <= a ? r[i][u] = -f : r[i][u] = -(1 - f) * a / f : d >= 0 ? r[i][u] = -d : r[i][u] = d * a / (1 - a) } return !0 }; Fe.prototype.applyMIRCuts = function () { } }); var kr = V(() => { var Y = Q(); Y.prototype._putInBase = function (e) { var t = this.rowByVarIndex[e]; if (t === -1) { for (var r = this.colByVarIndex[e], n = 1; n < this.height; n += 1) { var o = this.matrix[n][r]; if (o < -this.precision || this.precision < o) { t = n; break } } this.pivot(t, r) } return t }; Y.prototype._takeOutOfBase = function (e) { var t = this.colByVarIndex[e]; if (t === -1) { for (var r = this.rowByVarIndex[e], n = this.matrix[r], o = 1; o < this.height; o += 1) { var a = n[o]; if (a < -this.precision || this.precision < a) { t = o; break } } this.pivot(r, t) } return t }; Y.prototype.updateVariableValues = function () { for (var e = this.variables.length, t = Math.round(1 / this.precision), r = 0; r < e; r += 1) { var n = this.variables[r], o = n.index, a = this.rowByVarIndex[o]; if (a === -1) n.value = 0; else { var i = this.matrix[a][this.rhsColumn]; n.value = Math.round((i + Number.EPSILON) * t) / t } } }; Y.prototype.updateRightHandSide = function (e, t) { var r = this.height - 1, n = this.rowByVarIndex[e.index]; if (n === -1) { for (var o = this.colByVarIndex[e.index], a = 0; a <= r; a += 1) { var i = this.matrix[a]; i[this.rhsColumn] -= t * i[o] } var s = this.optionalObjectives.length; if (s > 0) for (var u = 0; u < s; u += 1) { var l = this.optionalObjectives[u].reducedCosts; l[this.rhsColumn] -= t * l[o] } } else this.matrix[n][this.rhsColumn] -= t }; Y.prototype.updateConstraintCoefficient = function (e, t, r) { if (e.index === t.index) throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !"); var n = this._putInBase(e.index), o = this.colByVarIndex[t.index]; if (o === -1) for (var a = this.rowByVarIndex[t.index], i = 0; i < this.width; i += 1)this.matrix[n][i] += r * this.matrix[a][i]; else this.matrix[n][o] -= r }; Y.prototype.updateCost = function (e, t) { var r = e.index, n = this.width - 1, o = this.colByVarIndex[r]; if (o === -1) { var a = this.matrix[this.rowByVarIndex[r]], i; if (e.priority === 0) { var s = this.matrix[0]; for (i = 0; i <= n; i += 1)s[i] += t * a[i] } else { var u = this.objectivesByPriority[e.priority].reducedCosts; for (i = 0; i <= n; i += 1)u[i] += t * a[i] } } else this.matrix[0][o] -= t }; Y.prototype.addConstraint = function (e) { var t = e.isUpperBound ? 1 : -1, r = this.height, n = this.matrix[r]; n === void 0 && (n = this.matrix[0].slice(), this.matrix[r] = n); for (var o = this.width - 1, a = 0; a <= o; a += 1)n[a] = 0; n[this.rhsColumn] = t * e.rhs; for (var i = e.terms, s = i.length, u = 0; u < s; u += 1) { var l = i[u], d = l.coefficient, f = l.variable.index, h = this.rowByVarIndex[f]; if (h === -1) n[this.colByVarIndex[f]] += t * d; else { var m = this.matrix[h], p = m[this.rhsColumn]; for (a = 0; a <= o; a += 1)n[a] -= t * d * m[a] } } var c = e.index; this.varIndexByRow[r] = c, this.rowByVarIndex[c] = r, this.colByVarIndex[c] = -1, this.height += 1 }; Y.prototype.removeConstraint = function (e) { var t = e.index, r = this.height - 1, n = this._putInBase(t), o = this.matrix[r]; this.matrix[r] = this.matrix[n], this.matrix[n] = o, this.varIndexByRow[n] = this.varIndexByRow[r], this.varIndexByRow[r] = -1, this.rowByVarIndex[t] = -1, this.availableIndexes[this.availableIndexes.length] = t, e.slack.index = -1, this.height -= 1 }; Y.prototype.addVariable = function (e) { var t = this.height - 1, r = this.width, n = this.model.isMinimization === !0 ? -e.cost : e.cost, o = e.priority, a = this.optionalObjectives.length; if (a > 0) for (var i = 0; i < a; i += 1)this.optionalObjectives[i].reducedCosts[r] = 0; o === 0 ? this.matrix[0][r] = n : (this.setOptionalObjective(o, r, n), this.matrix[0][r] = 0); for (var s = 1; s <= t; s += 1)this.matrix[s][r] = 0; var u = e.index; this.varIndexByCol[r] = u, this.rowByVarIndex[u] = -1, this.colByVarIndex[u] = r, this.width += 1 }; Y.prototype.removeVariable = function (e) { var t = e.index, r = this._takeOutOfBase(t), n = this.width - 1; if (r !== n) { for (var o = this.height - 1, a = 0; a <= o; a += 1) { var i = this.matrix[a]; i[r] = i[n] } var s = this.optionalObjectives.length; if (s > 0) for (var u = 0; u < s; u += 1) { var l = this.optionalObjectives[u].reducedCosts; l[r] = l[n] } var d = this.varIndexByCol[n]; this.varIndexByCol[r] = d, this.colByVarIndex[d] = r } this.varIndexByCol[n] = -1, this.colByVarIndex[t] = -1, this.availableIndexes[this.availableIndexes.length] = t, e.index = -1, this.width -= 1 } }); var Mr = V(() => { var ti = Q(); ti.prototype.log = function (e, t) { console.log("****", e, "****"), console.log("Nb Variables", this.width - 1), console.log("Nb Constraints", this.height - 1), console.log("Basic Indexes", this.varIndexByRow), console.log("Non Basic Indexes", this.varIndexByCol), console.log("Rows", this.rowByVarIndex), console.log("Cols", this.colByVarIndex); var r = 5, n = "", o = [" "], a, i, s, u, l, d, f, h, m, p, c, x, N; for (i = 1; i < this.width; i += 1)d = this.varIndexByCol[i], l = this.variablesPerIndex[d], l === void 0 ? f = "c" + d : f = l.id, h = f.length, m = Math.abs(h - 5), p = " ", c = "	", h > 5 ? p += " " : c += "	", o[i] = p, n += c + f; console.log(n); var v, b = this.matrix[this.costRowIndex], y = "	"; for (a = 1; a < this.width; a += 1)v = "	", y += v, y += o[a], y += b[a].toFixed(r); for (v = "	", y += v + o[0] + b[0].toFixed(r), console.log(y + "	Z"), u = 1; u < this.height; u += 1) { for (x = this.matrix[u], N = "	", i = 1; i < this.width; i += 1)v = "	", N += v + o[i] + x[i].toFixed(r); v = "	", N += v + o[0] + x[0].toFixed(r), d = this.varIndexByRow[u], l = this.variablesPerIndex[d], l === void 0 ? f = "c" + d : f = l.id, console.log(N + "	" + f) } console.log(""); var w = this.optionalObjectives.length; if (w > 0) { console.log("    Optional objectives:"); for (var D = 0; D < w; D += 1) { var L = this.optionalObjectives[D].reducedCosts, O = ""; for (a = 1; a < this.width; a += 1)v = L[a] < 0 ? "" : " ", O += v, O += o[a], O += L[a].toFixed(r); v = L[0] < 0 ? "" : " ", O += v + o[0] + L[0].toFixed(r), console.log(O + " z" + D) } } return console.log("Feasible?", this.feasible), console.log("evaluation", this.evaluation), this } }); var zr = V(() => { var je = Q(); je.prototype.copy = function () { var e = new je(this.precision); e.width = this.width, e.height = this.height, e.nVars = this.nVars, e.model = this.model, e.variables = this.variables, e.variablesPerIndex = this.variablesPerIndex, e.unrestrictedVars = this.unrestrictedVars, e.lastElementIndex = this.lastElementIndex, e.varIndexByRow = this.varIndexByRow.slice(), e.varIndexByCol = this.varIndexByCol.slice(), e.rowByVarIndex = this.rowByVarIndex.slice(), e.colByVarIndex = this.colByVarIndex.slice(), e.availableIndexes = this.availableIndexes.slice(); for (var t = [], r = 0; r < this.optionalObjectives.length; r++)t[r] = this.optionalObjectives[r].copy(); e.optionalObjectives = t; for (var n = this.matrix, o = new Array(this.height), a = 0; a < this.height; a++)o[a] = n[a].slice(); return e.matrix = o, e }; je.prototype.save = function () { this.savedState = this.copy() }; je.prototype.restore = function () { if (this.savedState !== null) { var e = this.savedState, t = e.matrix; this.nVars = e.nVars, this.model = e.model, this.variables = e.variables, this.variablesPerIndex = e.variablesPerIndex, this.unrestrictedVars = e.unrestrictedVars, this.lastElementIndex = e.lastElementIndex, this.width = e.width, this.height = e.height; var r, n; for (r = 0; r < this.height; r += 1) { var o = t[r], a = this.matrix[r]; for (n = 0; n < this.width; n += 1)a[n] = o[n] } var i = e.varIndexByRow; for (n = 0; n < this.height; n += 1)this.varIndexByRow[n] = i[n]; for (; this.varIndexByRow.length > this.height;)this.varIndexByRow.pop(); var s = e.varIndexByCol; for (r = 0; r < this.width; r += 1)this.varIndexByCol[r] = s[r]; for (; this.varIndexByCol.length > this.width;)this.varIndexByCol.pop(); for (var u = e.rowByVarIndex, l = e.colByVarIndex, d = 0; d < this.nVars; d += 1)this.rowByVarIndex[d] = u[d], this.colByVarIndex[d] = l[d]; if (e.optionalObjectives.length > 0 && this.optionalObjectives.length > 0) { this.optionalObjectives = [], this.optionalObjectivePerPriority = {}; for (var f = 0; f < e.optionalObjectives.length; f++) { var h = e.optionalObjectives[f].copy(); this.optionalObjectives[f] = h, this.optionalObjectivePerPriority[h.priority] = h } } } } }); var Er = V(() => { var Ar = Q(); function Tr(e, t) { this.index = e, this.value = t } Ar.prototype.getMostFractionalVar = function () { for (var e = 0, t = null, r = null, n = .5, o = this.model.integerVariables, a = o.length, i = 0; i < a; i++) { var s = o[i].index, u = this.rowByVarIndex[s]; if (u !== -1) { var l = this.matrix[u][this.rhsColumn], d = Math.abs(l - Math.round(l)); e < d && (e = d, t = s, r = l) } } return new Tr(t, r) }; Ar.prototype.getFractionalVarWithLowestCost = function () { for (var e = 1 / 0, t = null, r = null, n = this.model.integerVariables, o = n.length, a = 0; a < o; a++) { var i = n[a], s = i.index, u = this.rowByVarIndex[s]; if (u !== -1) { var l = this.matrix[u][this.rhsColumn]; if (Math.abs(l - Math.round(l)) > this.precision) { var d = i.cost; e > d && (e = d, t = s, r = l) } } } return new Tr(t, r) } }); var Vr = V(() => { var Mt = Q(); Mt.prototype.countIntegerValues = function () { for (var e = 0, t = 1; t < this.height; t += 1)if (this.variablesPerIndex[this.varIndexByRow[t]].isInteger) { var r = this.matrix[t][this.rhsColumn]; r = r - Math.floor(r), r < this.precision && -r < this.precision && (e += 1) } return e }; Mt.prototype.isIntegral = function () { for (var e = this.model.integerVariables, t = e.length, r = 0; r < t; r++) { var n = this.rowByVarIndex[e[r].index]; if (n !== -1) { var o = this.matrix[n][this.rhsColumn]; if (Math.abs(o - Math.round(o)) > this.precision) return !1 } } return !0 }; Mt.prototype.computeFractionalVolume = function (e) { for (var t = -1, r = 1; r < this.height; r += 1)if (this.variablesPerIndex[this.varIndexByRow[r]].isInteger) { var n = this.matrix[r][this.rhsColumn]; n = Math.abs(n); var o = Math.min(n - Math.floor(n), Math.floor(n + 1)); if (o < this.precision) { if (!e) return 0 } else t === -1 ? t = n : t *= n } return t === -1 ? 0 : t } }); var Br = V((Nf, Pr) => { wr(); Ir(); kr(); Mr(); zr(); Er(); Vr(); Pr.exports = Q() }); var At = V(() => { var _r = Q(); function Rr(e, t, r) { this.type = e, this.varIndex = t, this.value = r } function zt(e, t) { this.relaxedEvaluation = e, this.cuts = t } function ri(e, t) { return t.relaxedEvaluation - e.relaxedEvaluation } _r.prototype.applyCuts = function (e) { if (this.restore(), this.addCutConstraints(e), this.simplex(), this.model.useMIRCuts) for (var t = !0; t;) { var r = this.computeFractionalVolume(!0); this.applyMIRCuts(), this.simplex(); var n = this.computeFractionalVolume(!0); n >= .9 * r && (t = !1) } }; _r.prototype.branchAndCut = function () { var e = [], t = 0, r = this.model.tolerance, n = !0, o = 1e99; this.model.timeout && (o = Date.now() + this.model.timeout); for (var a = 1 / 0, i = null, s = [], u = 0; u < this.optionalObjectives.length; u += 1)s.push(1 / 0); var l = new zt(-1 / 0, []), d; for (e.push(l); e.length > 0 && n === !0 && Date.now() < o;)if (this.model.isMinimization ? d = this.bestPossibleEval * (1 + r) : d = this.bestPossibleEval * (1 - r), r > 0 && a < d && (n = !1), l = e.pop(), !(l.relaxedEvaluation > a)) { var f = l.cuts; if (this.applyCuts(f), t++, this.feasible !== !1) { var h = this.evaluation; if (!(h > a)) { if (h === a) { for (var m = !0, p = 0; p < this.optionalObjectives.length && !(this.optionalObjectives[p].reducedCosts[0] > s[p]); p += 1)if (this.optionalObjectives[p].reducedCosts[0] < s[p]) { m = !1; break } if (m) continue } if (this.isIntegral() === !0) { if (this.__isIntegral = !0, t === 1) { this.branchAndCutIterations = t; return } i = l, a = h; for (var c = 0; c < this.optionalObjectives.length; c += 1)s[c] = this.optionalObjectives[c].reducedCosts[0] } else { t === 1 && this.save(); for (var x = this.getMostFractionalVar(), N = x.index, v = [], b = [], y = f.length, w = 0; w < y; w += 1) { var D = f[w]; D.varIndex === N ? D.type === "min" ? b.push(D) : v.push(D) : (v.push(D), b.push(D)) } var L = Math.ceil(x.value), O = Math.floor(x.value), S = new Rr("min", N, L); v.push(S); var C = new Rr("max", N, O); b.push(C), e.push(new zt(h, v)), e.push(new zt(h, b)), e.sort(ri) } } } } i !== null && this.applyCuts(i.cuts), this.branchAndCutIterations = t } }); var Ur = V((wf, $r) => { var ni = Q(), bf = At(), Ce = qe(), He = Ce.Constraint, Wr = Ce.Equality, oi = Ce.Variable, ii = Ce.IntegerVariable, Of = Ce.Term; function R(e, t) { this.tableau = new ni(e), this.name = t, this.variables = [], this.integerVariables = [], this.unrestrictedVariables = {}, this.constraints = [], this.nConstraints = 0, this.nVariables = 0, this.isMinimization = !0, this.tableauInitialized = !1, this.relaxationIndex = 1, this.useMIRCuts = !1, this.checkForCycles = !0, this.messages = [] } $r.exports = R; R.prototype.minimize = function () { return this.isMinimization = !0, this }; R.prototype.maximize = function () { return this.isMinimization = !1, this }; R.prototype._getNewElementIndex = function () { if (this.availableIndexes.length > 0) return this.availableIndexes.pop(); var e = this.lastElementIndex; return this.lastElementIndex += 1, e }; R.prototype._addConstraint = function (e) { var t = e.slack; this.tableau.variablesPerIndex[t.index] = t, this.constraints.push(e), this.nConstraints += 1, this.tableauInitialized === !0 && this.tableau.addConstraint(e) }; R.prototype.smallerThan = function (e) { var t = new He(e, !0, this.tableau.getNewElementIndex(), this); return this._addConstraint(t), t }; R.prototype.greaterThan = function (e) { var t = new He(e, !1, this.tableau.getNewElementIndex(), this); return this._addConstraint(t), t }; R.prototype.equal = function (e) { var t = new He(e, !0, this.tableau.getNewElementIndex(), this); this._addConstraint(t); var r = new He(e, !1, this.tableau.getNewElementIndex(), this); return this._addConstraint(r), new Wr(t, r) }; R.prototype.addVariable = function (e, t, r, n, o) { if (typeof o == "string") switch (o) { case "required": o = 0; break; case "strong": o = 1; break; case "medium": o = 2; break; case "weak": o = 3; break; default: o = 0; break }var a = this.tableau.getNewElementIndex(); t == null && (t = "v" + a), e == null && (e = 0), o == null && (o = 0); var i; return r ? (i = new ii(t, e, a, o), this.integerVariables.push(i)) : i = new oi(t, e, a, o), this.variables.push(i), this.tableau.variablesPerIndex[a] = i, n && (this.unrestrictedVariables[a] = !0), this.nVariables += 1, this.tableauInitialized === !0 && this.tableau.addVariable(i), i }; R.prototype._removeConstraint = function (e) { var t = this.constraints.indexOf(e); if (t === -1) { console.warn("[Model.removeConstraint] Constraint not present in model"); return } this.constraints.splice(t, 1), this.nConstraints -= 1, this.tableauInitialized === !0 && this.tableau.removeConstraint(e), e.relaxation && this.removeVariable(e.relaxation) }; R.prototype.removeConstraint = function (e) { return e.isEquality ? (this._removeConstraint(e.upperBound), this._removeConstraint(e.lowerBound)) : this._removeConstraint(e), this }; R.prototype.removeVariable = function (e) { var t = this.variables.indexOf(e); if (t === -1) { console.warn("[Model.removeVariable] Variable not present in model"); return } return this.variables.splice(t, 1), this.tableauInitialized === !0 && this.tableau.removeVariable(e), this }; R.prototype.updateRightHandSide = function (e, t) { return this.tableauInitialized === !0 && this.tableau.updateRightHandSide(e, t), this }; R.prototype.updateConstraintCoefficient = function (e, t, r) { return this.tableauInitialized === !0 && this.tableau.updateConstraintCoefficient(e, t, r), this }; R.prototype.setCost = function (e, t) { var r = e - t.cost; return this.isMinimization === !1 && (r = -r), t.cost = e, this.tableau.updateCost(t, r), this }; R.prototype.loadJson = function (e) { this.isMinimization = e.opType !== "max"; for (var t = e.variables, r = e.constraints, n = {}, o = {}, a = Object.keys(r), i = a.length, s = 0; s < i; s += 1) { var u = a[s], l = r[u], d = l.equal, f = l.weight, h = l.priority, m = f !== void 0 || h !== void 0, p, c; if (d === void 0) { var x = l.min; x !== void 0 && (p = this.greaterThan(x), n[u] = p, m && p.relax(f, h)); var N = l.max; N !== void 0 && (c = this.smallerThan(N), o[u] = c, m && c.relax(f, h)) } else { p = this.greaterThan(d), n[u] = p, c = this.smallerThan(d), o[u] = c; var v = new Wr(p, c); m && v.relax(f, h) } } var b = Object.keys(t), y = b.length; this.tolerance = e.tolerance || 0, e.timeout && (this.timeout = e.timeout), e.options && (e.options.timeout && (this.timeout = e.options.timeout), this.tolerance === 0 && (this.tolerance = e.options.tolerance || 0), e.options.useMIRCuts && (this.useMIRCuts = e.options.useMIRCuts), typeof e.options.exitOnCycles > "u" ? this.checkForCycles = !0 : this.checkForCycles = e.options.exitOnCycles); for (var w = e.ints || {}, D = e.binaries || {}, L = e.unrestricted || {}, O = e.optimize, S = 0; S < y; S += 1) { var C = b[S], k = t[C], M = k[O] || 0, A = !!D[C], E = !!w[C] || A, T = !!L[C], z = this.addVariable(M, C, E, T); A && this.smallerThan(1).addTerm(1, z); var W = Object.keys(k); for (s = 0; s < W.length; s += 1) { var G = W[s]; if (G !== O) { var $ = k[G], B = n[G]; B !== void 0 && B.addTerm($, z); var ee = o[G]; ee !== void 0 && ee.addTerm($, z) } } } return this }; R.prototype.getNumberOfIntegerVariables = function () { return this.integerVariables.length }; R.prototype.solve = function () { return this.tableauInitialized === !1 && (this.tableau.setModel(this), this.tableauInitialized = !0), this.tableau.solve() }; R.prototype.isFeasible = function () { return this.tableau.feasible }; R.prototype.save = function () { return this.tableau.save() }; R.prototype.restore = function () { return this.tableau.restore() }; R.prototype.activateMIRCuts = function (e) { this.useMIRCuts = e }; R.prototype.debug = function (e) { this.checkForCycles = e }; R.prototype.log = function (e) { return this.tableau.log(e) } }); var qr = V(Gr => { Gr.CleanObjectiveAttributes = function (e) { var t, r, n; if (typeof e.optimize == "string") if (e.constraints[e.optimize]) { t = Math.random(); for (r in e.variables) e.variables[r][e.optimize] && (e.variables[r][t] = e.variables[r][e.optimize]); return e.constraints[t] = e.constraints[e.optimize], delete e.constraints[e.optimize], e } else return e; else { for (n in e.optimize) if (e.constraints[n]) if (e.constraints[n] === "equal") delete e.optimize[n]; else { t = Math.random(); for (r in e.variables) e.variables[r][n] && (e.variables[r][t] = e.variables[r][n]); e.constraints[t] = e.constraints[n], delete e.constraints[n] } return e } } }); var Ze = V((Sf, Fr) => {
                function ai(e) {
                    var t = { is_blank: /^\W{0,}$/, is_objective: /(max|min)(imize){0,}\:/i, is_int: /^(?!\/\*)\W{0,}int/i, is_bin: /^(?!\/\*)\W{0,}bin/i, is_constraint: /(\>|\<){0,}\=/i, is_unrestricted: /^\S{0,}unrestricted/i, parse_lhs: /(\-|\+){0,1}\s{0,1}\d{0,}\.{0,}\d{0,}\s{0,}[A-Za-z]\S{0,}/gi, parse_rhs: /(\-|\+){0,1}\d{1,}\.{0,}\d{0,}\W{0,}\;{0,1}$/i, parse_dir: /(\>|\<){0,}\=/gi, parse_int: /[^\s|^\,]+/gi, parse_bin: /[^\s|^\,]+/gi, get_num: /(\-|\+){0,1}(\W|^)\d+\.{0,1}\d{0,}/g, get_word: /[A-Za-z].*/ }, r = { opType: "", optimize: "_obj", constraints: {}, variables: {} }, n = { ">=": "min", "<=": "max", "=": "equal" }, o = "", a = 0, i = null, s = "", u = "", l = "", d = 0; typeof e == "string" && (e = e.split(`
    `)); for (var f = 0; f < e.length; f++)if (l = "__" + f, o = e[f], a = 0, i = null, t.is_objective.test(o)) r.opType = o.match(/(max|min)/gi)[0], i = o.match(t.parse_lhs).map(function (p) { return p.replace(/\s+/, "") }).slice(1), i.forEach(function (p) { s = p.match(t.get_num), s === null ? p.substr(0, 1) === "-" ? s = -1 : s = 1 : s = s[0], s = parseFloat(s), u = p.match(t.get_word)[0].replace(/\;$/, ""), r.variables[u] = r.variables[u] || {}, r.variables[u]._obj = s }); else if (t.is_int.test(o)) i = o.match(t.parse_int).slice(1), r.ints = r.ints || {}, i.forEach(function (p) { p = p.replace(";", ""), r.ints[p] = 1 }); else if (t.is_bin.test(o)) i = o.match(t.parse_bin).slice(1), r.binaries = r.binaries || {}, i.forEach(function (p) { p = p.replace(";", ""), r.binaries[p] = 1 }); else if (t.is_constraint.test(o)) { var h = o.indexOf(":"), m = h === -1 ? o : o.slice(h + 1); i = m.match(t.parse_lhs).map(function (p) { return p.replace(/\s+/, "") }), i.forEach(function (p) { s = p.match(t.get_num), s === null ? p.substr(0, 1) === "-" ? s = -1 : s = 1 : s = s[0], s = parseFloat(s), u = p.match(t.get_word)[0], r.variables[u] = r.variables[u] || {}, r.variables[u][l] = s }), d = parseFloat(o.match(t.parse_rhs)[0]), o = n[o.match(t.parse_dir)[0]], r.constraints[l] = r.constraints[l] || {}, r.constraints[l][o] = d } else t.is_unrestricted.test(o) && (i = o.match(t.parse_int).slice(1), r.unrestricted = r.unrestricted || {}, i.forEach(function (p) { p = p.replace(";", ""), r.unrestricted[p] = 1 })); return r
                } function si(e) {
                    if (!e) throw new Error("Solver requires a model to operate on"); var t = "", r = [], n = 1, o = { max: "<=", min: ">=", equal: "=" }, a = new RegExp("[^A-Za-z0-9_[{}/.&#$%~'@^]", "gi"); if (e.opType) { t += e.opType + ":"; for (var i in e.variables) e.variables[i][i] = e.variables[i][i] ? e.variables[i][i] : 1, e.variables[i][e.optimize] && (t += " " + e.variables[i][e.optimize] + " " + i.replace(a, "_")) } else t += "max:"; t += `;
    
    `; for (var s in e.constraints) for (var u in e.constraints[s]) if (typeof o[u] < "u") {
                        for (var l in e.variables) typeof e.variables[l][s] < "u" && (t += " " + e.variables[l][s] + " " + l.replace(a, "_")); t += " " + o[u] + " " + e.constraints[s][u], t += `;
    `} if (e.ints) {
                        t += `
    
    `; for (var d in e.ints) t += "int " + d.replace(a, "_") + `;
    `} if (e.unrestricted) {
                        t += `
    
    `; for (var f in e.unrestricted) t += "unrestricted " + f.replace(a, "_") + `;
    `} return t
                } Fr.exports = function (e) { return e.length ? ai(e) : si(e) }
            }); var jr = V(() => { }); var Hr = V(() => { }); var Qr = V(Tt => {
                Tt.reformat = Ze(); function Zr(e) {
                    return e = e.replace("\\r\\n", `\r
    `), e = e.split(`\r
    `), e = e.filter(function (t) { var r; return r = new RegExp(" 0$", "gi"), !(r.test(t) === !0 || (r = new RegExp("\\d$", "gi"), r.test(t) === !1)) }).map(function (t) { return t.split(/\:{0,1} +(?=\d)/) }).reduce(function (t, r, n) { return t[r[0]] = r[1], t }, {}), e
                } Tt.solve = function (e) { return new Promise(function (t, r) { typeof window < "u" && r("Function Not Available in Browser"); var n = Ze()(e); e.external || r("Data for this function must be contained in the 'external' attribute. Not seeing anything there."), e.external.binPath || r("No Executable | Binary path provided in arguments as 'binPath'"), e.external.args || r("No arguments array for cli | bash provided on 'args' attribute"), e.external.tempName || r("No 'tempName' given. This is necessary to produce a staging file for the solver to operate on"); var o = jr(); o.writeFile(e.external.tempName, n, function (a, i) { if (a) r(a); else { var s = Hr().execFile; e.external.args.push(e.external.tempName), s(e.external.binPath, e.external.args, function (u, l) { if (u) if (u.code === 1) t(Zr(l)); else { var d = { "-2": "Out of Memory", 1: "SUBOPTIMAL", 2: "INFEASIBLE", 3: "UNBOUNDED", 4: "DEGENERATE", 5: "NUMFAILURE", 6: "USER-ABORT", 7: "TIMEOUT", 9: "PRESOLVED", 25: "ACCURACY ERROR", 255: "FILE-ERROR" }, f = { code: u.code, meaning: d[u.code], data: l }; r(f) } else t(Zr(l)) }) } }) }) }
            }); var Kr = V((zf, Jr) => { Jr.exports = { lpsolve: Qr() } }); var Et = V((Af, Yr) => { Yr.exports = function (e, t) { var r = t.optimize, n = JSON.parse(JSON.stringify(t.optimize)), o = Object.keys(t.optimize), a, i = 0, s = {}, u = "", l = {}, d = [], f, h, m, p, c; for (delete t.optimize, f = 0; f < o.length; f++)n[o[f]] = 0; for (f = 0; f < o.length; f++) { t.optimize = o[f], t.opType = r[o[f]], a = e.Solve(t, void 0, void 0, !0); for (p in o) if (!t.variables[o[p]]) { a[o[p]] = a[o[p]] ? a[o[p]] : 0; for (m in t.variables) t.variables[m][o[p]] && a[m] && (a[o[p]] += a[m] * t.variables[m][o[p]]) } for (u = "base", h = 0; h < o.length; h++)a[o[h]] ? u += "-" + (a[o[h]] * 1e3 | 0) / 1e3 : u += "-0"; if (!s[u]) { for (s[u] = 1, i++, h = 0; h < o.length; h++)a[o[h]] && (n[o[h]] += a[o[h]]); delete a.feasible, delete a.result, d.push(a) } } for (f = 0; f < o.length; f++)t.constraints[o[f]] = { equal: n[o[f]] / i }; t.optimize = "cheater-" + Math.random(), t.opType = "max"; for (f in t.variables) t.variables[f].cheater = 1; for (f in d) for (m in d[f]) l[m] = l[m] || { min: 1e99, max: -1e99 }; for (f in l) for (m in d) d[m][f] ? (d[m][f] > l[f].max && (l[f].max = d[m][f]), d[m][f] < l[f].min && (l[f].min = d[m][f])) : (d[m][f] = 0, l[f].min = 0); return a = e.Solve(t, void 0, void 0, !0), { midpoint: a, vertices: d, ranges: l } } }); var tn = V((Tf, en) => { var ui = Br(), Vt = Ur(), di = At(), Ke = qe(), Xr = qr(), fi = Ke.Constraint, li = Ke.Variable, ci = Ke.Numeral, pi = Ke.Term, Qe = Kr(), Je = function () { "use strict"; this.Model = Vt, this.branchAndCut = di, this.Constraint = fi, this.Variable = li, this.Numeral = ci, this.Term = pi, this.Tableau = ui, this.lastSolvedModel = null, this.External = Qe, this.Solve = function (e, t, r, n) { if (n) for (var o in Xr) e = Xr[o](e); if (!e) throw new Error("Solver requires a model to operate on"); if (typeof e.optimize == "object" && Object.keys(e.optimize > 1)) return Et()(this, e); if (e.external) { var a = Object.keys(Qe); if (a = JSON.stringify(a), !e.external.solver) throw new Error("The model you provided has an 'external' object that doesn't have a solver attribute. Use one of the following:" + a); if (!Qe[e.external.solver]) throw new Error("No support (yet) for " + e.external.solver + ". Please use one of these instead:" + a); return Qe[e.external.solver].solve(e) } else { e instanceof Vt || (e = new Vt(t).loadJson(e)); var i = e.solve(); if (this.lastSolvedModel = e, i.solutionSet = i.generateSolutionSet(), r) return i; var s = {}; return s.feasible = i.feasible, s.result = i.evaluation, s.bounded = i.bounded, i._tableau.__isIntegral && (s.isIntegral = !0), Object.keys(i.solutionSet).forEach(function (u) { i.solutionSet[u] !== 0 && (s[u] = i.solutionSet[u]) }), s } }, this.ReformatLP = Ze(), this.MultiObjective = function (e) { return Et()(this, e) } }; typeof define == "function" ? define([], function () { return new Je }) : typeof window == "object" ? window.solver = new Je : typeof self == "object" && (self.solver = new Je); en.exports = new Je }); var un = V((Uf, sn) => { "use strict"; var Ie = 1e-60, on, an; do Ie += Ie, on = 1 + .1 * Ie, an = 1 + .2 * Ie; while (on <= 1 || an <= 1); sn.exports = Ie }); var fn = V((Gf, dn) => { "use strict"; function mi(e, t, r) { let n, o; for (let a = 1; a <= r; a += 1) { e[a][a] = 1 / e[a][a], o = -e[a][a]; for (let i = 1; i < a; i += 1)e[i][a] *= o; if (n = a + 1, r < n) break; for (let i = n; i <= r; i += 1) { o = e[a][i], e[a][i] = 0; for (let s = 1; s <= a; s += 1)e[s][i] += o * e[s][a] } } } dn.exports = mi }); var cn = V((qf, ln) => { "use strict"; function gi(e, t, r, n) { let o, a; for (o = 1; o <= r; o += 1) { a = 0; for (let i = 1; i < o; i += 1)a += e[i][o] * n[i]; n[o] = (n[o] - a) / e[o][o] } for (let i = 1; i <= r; i += 1) { o = r + 1 - i, n[o] /= e[o][o], a = -n[o]; for (let s = 1; s < o; s += 1)n[s] += a * e[s][o] } } ln.exports = gi }); var hn = V((Ff, pn) => { "use strict"; function xi(e, t, r, n) { let o, a, i; for (let s = 1; s <= r; s += 1) { if (n[1] = s, i = 0, o = s - 1, o < 1) { if (i = e[s][s] - i, i <= 0) break; e[s][s] = Math.sqrt(i) } else { for (let u = 1; u <= o; u += 1) { a = e[u][s]; for (let l = 1; l < u; l += 1)a -= e[l][s] * e[l][u]; a /= e[u][u], e[u][s] = a, i += a * a } if (i = e[s][s] - i, i <= 0) break; e[s][s] = Math.sqrt(i) } n[1] = 0 } } pn.exports = xi }); var gn = V((jf, mn) => { "use strict"; var Bt = un(), Ni = fn(), vi = cn(), yi = hn(); function bi(e, t, r, n, o, a, i, s, u, l, d, f, h, m = 0, p, c, x) { let N, v, b, y, w, D, L, O, S, C, k, M, A, E, T = Math.min(n, d), z = 2 * n + T * (T + 5) / 2 + 2 * d + 1; for (let g = 1; g <= n; g += 1)c[g] = t[g]; for (let g = n + 1; g <= z; g += 1)c[g] = 0; for (let g = 1; g <= d; g += 1)h[g] = 0, a[g] = 0; let W = []; if (x[1] === 0) { if (yi(e, r, n, W), W[1] !== 0) { x[1] = 2; return } vi(e, r, n, t), Ni(e, r, n) } else { for (let g = 1; g <= n; g += 1) { o[g] = 0; for (let I = 1; I <= g; I += 1)o[g] += e[I][g] * t[I] } for (let g = 1; g <= n; g += 1) { t[g] = 0; for (let I = g; I <= n; I += 1)t[g] += e[g][I] * o[I] } } i[1] = 0; for (let g = 1; g <= n; g += 1) { o[g] = t[g], i[1] += c[g] * o[g], c[g] = 0; for (let I = g + 1; I <= n; I += 1)e[I][g] = 0 } i[1] = -i[1] / 2, x[1] = 0; let G = n, $ = G + n, B = $ + T, ee = B + T + 1, re = ee + T * (T + 1) / 2, pt = re + d; for (let g = 1; g <= d; g += 1) { D = 0; for (let I = 1; I <= n; I += 1)D += s[I][g] * s[I][g]; c[pt + g] = Math.sqrt(D) } y = m, p[1] = 0, p[2] = 0; function Yn() { p[1] += 1, z = re; for (let g = 1; g <= d; g += 1) { z += 1, D = -u[g]; for (let I = 1; I <= n; I += 1)D += s[I][g] * o[I]; if (Math.abs(D) < Bt && (D = 0), g > f) c[z] = D; else if (c[z] = -Math.abs(D), D > 0) { for (let I = 1; I <= n; I += 1)s[I][g] = -s[I][g]; u[g] = -u[g] } } for (let g = 1; g <= y; g += 1)c[re + h[g]] = 0; b = 0, w = 0; for (let g = 1; g <= d; g += 1)c[re + g] < w * c[pt + g] && (b = g, w = c[re + g] / c[pt + g]); if (b === 0) { for (let g = 1; g <= y; g += 1)a[h[g]] = c[B + g]; return 999 } return 0 } function Xn() { for (let g = 1; g <= n; g += 1) { D = 0; for (let I = 1; I <= n; I += 1)D += e[I][g] * s[I][b]; c[g] = D } N = G; for (let g = 1; g <= n; g += 1)c[N + g] = 0; for (let g = y + 1; g <= n; g += 1)for (let I = 1; I <= n; I += 1)c[N + I] = c[N + I] + e[I][g] * c[g]; M = !0; for (let g = y; g >= 1; g -= 1) { D = c[g], z = ee + g * (g + 3) / 2, N = z - g; for (let I = g + 1; I <= y; I += 1)D -= c[z] * c[$ + I], z += I; D /= c[N], c[$ + g] = D, !(h[g] <= f) && (D <= 0 || (M = !1, v = g)) } if (!M) { L = c[B + v] / c[$ + v]; for (let g = 1; g <= y; g += 1)h[g] <= f || c[$ + g] <= 0 || (w = c[B + g] / c[$ + g], w < L && (L = w, v = g)) } D = 0; for (let g = G + 1; g <= G + n; g += 1)D += c[g] * c[g]; if (Math.abs(D) <= Bt) { if (M) return x[1] = 1, 999; for (let g = 1; g <= y; g += 1)c[B + g] = c[B + g] - L * c[$ + g]; return c[B + y + 1] = c[B + y + 1] + L, 700 } D = 0; for (let g = 1; g <= n; g += 1)D += c[G + g] * s[g][b]; O = -c[re + b] / D, A = !0, M || L < O && (O = L, A = !1); for (let g = 1; g <= n; g += 1)o[g] += O * c[G + g], Math.abs(o[g]) < Bt && (o[g] = 0); i[1] += O * D * (O / 2 + c[B + y + 1]); for (let g = 1; g <= y; g += 1)c[B + g] = c[B + g] - O * c[$ + g]; if (c[B + y + 1] = c[B + y + 1] + O, A) { y += 1, h[y] = b, z = ee + (y - 1) * y / 2 + 1; for (let g = 1; g <= y - 1; g += 1)c[z] = c[g], z += 1; if (y === n) c[z] = c[n]; else { for (let g = n; g >= y + 1; g -= 1)if (c[g] !== 0 && (S = Math.max(Math.abs(c[g - 1]), Math.abs(c[g])), C = Math.min(Math.abs(c[g - 1]), Math.abs(c[g])), c[g - 1] >= 0 ? w = Math.abs(S * Math.sqrt(1 + C * C / (S * S))) : w = -Math.abs(S * Math.sqrt(1 + C * C / (S * S))), S = c[g - 1] / w, C = c[g] / w, S !== 1)) if (S === 0) { c[g - 1] = C * w; for (let I = 1; I <= n; I += 1)w = e[I][g - 1], e[I][g - 1] = e[I][g], e[I][g] = w } else { c[g - 1] = w, k = C / (1 + S); for (let I = 1; I <= n; I += 1)w = S * e[I][g - 1] + C * e[I][g], e[I][g] = k * (e[I][g - 1] + w) - e[I][g], e[I][g - 1] = w } c[z] = c[y] } } else { D = -u[b]; for (let g = 1; g <= n; g += 1)D += o[g] * s[g][b]; if (b > f) c[re + b] = D; else if (c[re + b] = -Math.abs(D), D > 0) { for (let g = 1; g <= n; g += 1)s[g][b] = -s[g][b]; u[b] = -u[b] } return 700 } return 0 } function eo() { if (z = ee + v * (v + 1) / 2 + 1, N = z + v, c[N] === 0 || (S = Math.max(Math.abs(c[N - 1]), Math.abs(c[N])), C = Math.min(Math.abs(c[N - 1]), Math.abs(c[N])), c[N - 1] >= 0 ? w = Math.abs(S * Math.sqrt(1 + C * C / (S * S))) : w = -Math.abs(S * Math.sqrt(1 + C * C / (S * S))), S = c[N - 1] / w, C = c[N] / w, S === 1)) return 798; if (S === 0) { for (let g = v + 1; g <= y; g += 1)w = c[N - 1], c[N - 1] = c[N], c[N] = w, N += g; for (let g = 1; g <= n; g += 1)w = e[g][v], e[g][v] = e[g][v + 1], e[g][v + 1] = w } else { k = C / (1 + S); for (let g = v + 1; g <= y; g += 1)w = S * c[N - 1] + C * c[N], c[N] = k * (c[N - 1] + w) - c[N], c[N - 1] = w, N += g; for (let g = 1; g <= n; g += 1)w = S * e[g][v] + C * e[g][v + 1], e[g][v + 1] = k * (e[g][v] + w) - e[g][v + 1], e[g][v] = w } return 0 } function to() { N = z - v; for (let g = 1; g <= v; g += 1)c[N] = c[z], z += 1, N += 1; return c[B + v] = c[B + v + 1], h[v] = h[v + 1], v += 1, v < y ? 797 : 0 } function Qt() { return c[B + y] = c[B + y + 1], c[B + y + 1] = 0, h[y] = 0, y -= 1, p[2] += 1, 0 } for (E = 0; ;) { if (E = Yn(), E === 999) return; for (; E = Xn(), E !== 0;) { if (E === 999) return; if (E === 700) if (v === y) Qt(); else { for (; eo(), E = to(), E === 797;); Qt() } } } } mn.exports = bi }); var Nn = V(xn => { "use strict"; var Oi = gn(); function wi(e, t, r, n = [], o = 0, a = [0, 0]) { let i = [], s = [], u = [], l = [], d = [], f = [], h = "", m = e.length - 1, p = r[1].length - 1; if (!n) for (let N = 1; N <= p; N += 1)n[N] = 0; if (m !== e[1].length - 1 && (h = "Dmat is not symmetric!"), m !== t.length - 1 && (h = "Dmat and dvec are incompatible!"), m !== r.length - 1 && (h = "Amat and dvec are incompatible!"), p !== n.length - 1 && (h = "Amat and bvec are incompatible!"), (o > p || o < 0) && (h = "Value of meq is invalid!"), h !== "") return { message: h }; for (let N = 1; N <= p; N += 1)s[N] = 0, l[N] = 0; let c = 0, x = Math.min(m, p); for (let N = 1; N <= m; N += 1)u[N] = 0; i[1] = 0; for (let N = 1; N <= 2 * m + x * (x + 5) / 2 + 2 * p + 1; N += 1)d[N] = 0; for (let N = 1; N <= 2; N += 1)f[N] = 0; return Oi(e, t, m, m, u, l, i, r, n, m, p, o, s, c, f, d, a), a[1] === 1 && (h = "constraints are inconsistent, no solution!"), a[1] === 2 && (h = "matrix D in quadratic function is not positive definite!"), { solution: u, Lagrangian: l, value: i, unconstrained_solution: t, iterations: f, iact: s, message: h } } xn.solveQP = wi }); var yn = V((Zf, vn) => { "use strict"; vn.exports = Nn() }); var Pi = {}; so(Pi, { aggMeanFactory: () => Sn, aggMedianFactory: () => Ln, aggWeightedMedianFactory: () => Ut, coordCenter: () => Pn, coordGreedy: () => Bn, coordQuad: () => _n, coordSimplex: () => ot, coordTopological: () => Wn, dagConnect: () => ar, dagHierarchy: () => Pe, dagStratify: () => dr, decrossDfs: () => ke, decrossOpt: () => $n, decrossTwoLayer: () => lt, grid: () => gr, laneGreedy: () => Ue, laneOpt: () => nn, layeringCoffmanGraham: () => qn, layeringLongestPath: () => jn, layeringSimplex: () => ct, layeringTopological: () => Hn, sugiCoordVertical: () => Ft, sugify: () => st, sugiyama: () => Vn, twolayerAgg: () => it, twolayerGreedy: () => at, twolayerOpt: () => Zn, unsugify: () => ut, zherebko: () => Kn }); function* H(e) { let t = 0; for (let r of e) yield [t++, r] } function* q(e, t) { for (let [r, n] of H(e)) yield* t(n, r) } function ht(e, t, r) { let n = r; for (let [o, a] of H(e)) n = t(n, a, o); return n } function* P(e, t) { for (let [r, n] of H(e)) yield t(n, r) } function* Kt(e, t) { for (let [r, n] of H(e)) t(n, r) && (yield n) } function de(e, t) { for (let [r, n] of H(e)) if (t(n, r)) return !0; return !1 } function Yt(e, t) { return !de(e, (r, n) => !t(r, n)) } function* Ae(e) { for (let t = e.length; t != 0;)yield e[--t] } function ge(e) { if (!e) throw new Error("internal error: failed assert") } function Xt(e, t) { if (t.size !== e.size) return !1; for (let r of e) if (!t.has(r)) return !1; return !0 } function er(e, t) { t.size < e.size && ([t, e] = [e, t]); for (let r of e) if (t.has(r)) return !0; return !1 } function Te(e) { let { done: t, value: r } = e.values().next(); if (!t) return e.delete(r), r } function ie(e, t, r) { let n = e.get(t); n === void 0 ? e.set(t, [r]) : n.push(r) } function Ee(e, t, r) { let n = e.get(t); n === void 0 ? e.set(t, new Set([r])) : n.add(r) } function fo() { let e = new WeakSet; return (t, r) => { if (typeof r == "object" && r !== null) { if (e.has(r)) return "[circular]"; e.add(r) } return r } } function F(e, ...t) { let [r, ...n] = e; return [r].concat(...n.map((o, a) => [JSON.stringify(t[a], fo()), o])).join("") } function* j(e) { let [t, ...r] = e; for (let n of r) yield [t, n], t = n } function* J(e, ...t) { let r = new Set, n; for (; (n = t.pop()) !== void 0;)r.has(n) || (yield n, r.add(n), t.push(...e(n))) } var rr = ze(mt()); function Z(e) { let t = new Map; for (let r of e) for (let n of r.ichildren()) ie(t, n, r); return t } function Ve(e) { let t = new Map; for (let r of e) for (let [n, o] of r.ichildrenCounts()) ie(t, n, [r, o]); return t } function* nr(e, t) { let r = new Map; for (let s of e) for (let u of s.ichildren()) r.set(u, (r.get(u) || 0) + 1); let n = new rr.default(([, s], [, u]) => s < u), o = []; function a(s) { let u = t(s); u === void 0 ? o.push(s) : n.add([s, u]) } for (let s of e.iroots()) a(s); let i; for (; i = o.pop() ?? n.poll()?.[0];) { yield i; for (let s of i.ichildren()) { let u = r.get(s); u > 1 ? r.set(s, u - 1) : a(s) } } } var le = class { constructor(t, r, n = [], o = !1) { this.child = t; this.data = r; this.points = n; this.reversed = o } }, gt = class { constructor(t, r, n, o, a) { this.source = t; this.target = r; this.data = n; this.points = o; this.reversed = a } }, te = class { constructor(t) { t && (this.proots = t) } [Symbol.iterator]() { return this.idescendants()[Symbol.iterator]() } iroots() { return { [Symbol.iterator]: () => this.proots[Symbol.iterator]() } } roots() { return [...this.iroots()] } *idepth() { yield* J(r => r.ichildren(), ...this.iroots()) } *ibreadth() { let t = new Set, r = this.roots(), n = []; do { n = r.reverse(), r = []; let o; for (; o = n.pop();)t.has(o) || (t.add(o), yield o, r.push(...o.ichildren())) } while (r.length) } *ibefore() { let t = new Map; for (let o of this) for (let a of o.ichildren()) t.set(a, (t.get(a) || 0) + 1); let r = this.roots(), n; for (; n = r.pop();) { yield n; for (let o of n.ichildren()) { let a = t.get(o); a > 1 ? t.set(o, a - 1) : r.push(o) } } } *iafter() { let t = this.roots(), r = new Set, n; for (; n = t.pop();)r.has(n) || (Yt(n.ichildren(), o => r.has(o)) ? (r.add(n), yield n) : t.push(n, ...n.ichildren())) } idescendants(t = "depth") { if (t === "depth") return this.idepth(); if (t === "breadth") return this.ibreadth(); if (t === "before") return this.ibefore(); if (t === "after") return this.iafter(); throw new Error(`unknown iteration style: ${t}`) } descendants(t = "depth") { return [...this.idescendants(t)] } ilinks() { return q(this, t => t.ichildLinks()) } links() { return [...this.ilinks()] } size() { return ht(this, t => t + 1, 0) } sum(t) { let r = new Map; for (let [n, o] of H(this.idescendants("after"))) { let a = t(o, n), i = new Map; i.set(o, a); for (let s of o.ichildren()) { let u = r.get(s); for (let [l, d] of u.entries()) i.set(l, d) } o.value = ht(i.values(), (s, u) => s + u, 0), r.set(o, i) } return this } count() { let t = new Map; for (let r of this.idescendants("after")) if (r.ichildren()[Symbol.iterator]().next().done) t.set(r, new Set([r])), r.value = 1; else { let n = new Set; for (let o of r.ichildren()) { let a = t.get(o); for (let i of a) n.add(i) } t.set(r, n), r.value = n.size } return this } height() { for (let t of this.idescendants("after")) t.value = Math.max(0, ...P(t.ichildren(), r => r.value + 1)); return this } depth() { let t = Z(this); for (let r of this.idescendants("before")) r.value = Math.max(0, ...P(t.get(r) ?? [], n => n.value + 1)); return this } *isplit() { let t = Z(this); function* r(o) { yield* o.ichildren(), yield* t.get(o) ?? [] } let n = new Set(this.iroots()); for (let o of this.iroots()) { if (!n.delete(o)) continue; let a = [o]; for (let i of J(r, o)) n.delete(i) && a.push(i); yield a.length > 1 ? new te(a) : a[0] } } split() { return [...this.isplit()] } connected() { let t = this.isplit()[Symbol.iterator](); t.next(); let { done: r } = t.next(); return !!r } multidag() { return this.pmultidag === void 0 ? this.pmultidag = de(this.iroots(), t => t.multidag()) : this.pmultidag } }, ce = class extends te { constructor(r) { super(); this.data = r; this.dataChildren = [] } childrenCountsMap() { if (this.cachedChildrenCounts === void 0) { let r = new Map; for (let { child: n } of this.dataChildren) r.set(n, (r.get(n) ?? 0) + 1); return this.cachedChildrenCounts = r.size === this.dataChildren.length ? null : r } else return this.cachedChildrenCounts } iroots() { let r = [this]; return { [Symbol.iterator]: () => r[Symbol.iterator]() } } nchildren() { return this.childrenCountsMap()?.size ?? this.dataChildren.length } nchildLinks() { return this.dataChildren.length } nchildLinksTo(r) { return this.childrenCountsMap()?.get(r) ?? 1 } *ichildren() { let r = this.childrenCountsMap(); if (r === null) for (let { child: n } of this.dataChildren) yield n; else yield* r.keys() } children() { return [...this.ichildren()] } *ichildrenCounts() { let r = this.childrenCountsMap(); if (r === null) for (let { child: n } of this.dataChildren) yield [n, 1]; else yield* r } childrenCounts() { return [...this.ichildrenCounts()] } *ichildLinks() { for (let { child: r, data: n, points: o, reversed: a } of this.dataChildren) yield new gt(this, r, n, o, a) } childLinks() { return [...this.ichildLinks()] } isplit() { return this.iroots() } split() { return this.roots() } connected() { return !0 } multidag() { return this.pmultidag === void 0 ? this.pmultidag = this.childrenCountsMap() !== null || de(this.ichildren(), r => r.multidag()) : this.pmultidag } }; function xt(e) { if (typeof e != "string") throw new Error(`id is supposed to be string but got type ${typeof e}`); return e } function Nt(e, t) { if (!e.length) throw new Error("dag contained no roots; this often indicates a cycle"); for (let i of new te(e)) for (let s of i.ichildren()) if (s === i) throw new Error(F`node '${i.data}' contained a self loop`); if (!t) return; let r = new Set, n = new Set, o = null; function a(i) { if (r.has(i)) return []; if (n.has(i)) return o = i, [i]; { n.add(i); let s = []; for (let u of i.ichildren()) if (s = a(u), s.length) break; return n.delete(i), r.add(i), s.length && o !== null && s.push(i), o === i && (o = null), s } } for (let i of e) { let s = a(i); if (s.length) { let u = s.reverse().map(({ data: l }) => F`'${l}'`).join(" -> "); throw new Error(`dag contained a cycle: ${u}`) } } } function co(e) { return e && Te(e) } function vt(e) { let t = new Map; for (let m of e) for (let { child: p } of m.dataChildren) ie(t, p, m); let r = new Map(P(e, m => [m, { indeg: t.get(m)?.length ?? 0, outdeg: m.nchildLinks(), node: m }])), n = Math.max(...P(Kt(r.values(), ({ indeg: m, outdeg: p }) => m > 0 && p > 0), ({ indeg: m, outdeg: p }) => p - m)); if (n === -1 / 0) { let m = []; for (let { indeg: p, node: c } of r.values()) p === 0 && m.push(c); return m } let o = new Set, a = new Set, i = new Map; for (let m of r.values()) { let { outdeg: p, indeg: c } = m; if (c === 0) o.add(m); else if (p === 0) a.add(m); else { let x = p - c; Ee(i, x, m) } } let s = 0, u = e.length, l = n, d = new Array(e.length); for (; s < u;) { let m = Te(o) ?? Te(a) ?? co(i.get(l)); if (m === void 0) --l; else { let { node: p, indeg: c, outdeg: x } = m, N = m.rank = c > 0 && x === 0 ? --u : s++; d[N] = p; for (let v of t.get(p) ?? []) { let b = r.get(v); if (b.rank === void 0 && b.indeg > 0 && b.outdeg > 0) { let y = b.outdeg - b.indeg; i.get(y).delete(b), --b.outdeg, b.outdeg > 0 ? Ee(i, y - 1, b) : a.add(b) } } for (let { child: v } of p.dataChildren) { let b = r.get(v); if (!(b.rank !== void 0 || b.indeg === 0)) if (b.outdeg === 0) --b.indeg, b.indeg === 0 && (a.delete(b), o.add(b)); else { let y = b.outdeg - b.indeg; y === l && ++l, i.get(y).delete(b), --b.indeg, b.indeg === 0 ? o.add(b) : Ee(i, y + 1, b) } } } } let f = [], h = new Set; for (let [m, p] of d.entries()) { let c = []; for (let x of p.dataChildren) { let N = r.get(x.child); N.rank < m ? N.node.dataChildren.push(new le(p, x.data, x.points, !0)) : c.push(x) } c.length === p.nchildLinks() && !h.has(p) && f.push(p); for (let { child: x } of c) h.add(x); p.dataChildren = c } return f } function po(e, t) { let r = []; for (let [n, o] of e.entries()) t.has(n) || r.push(o); return r } function fe(e) { function t(s) { if (!s.length) throw new Error("can't connect empty data"); let u = new Map, l = new Set; for (let [f, h] of s.entries()) { let m = xt(e.sourceId(h, f)), p = u.get(m); p === void 0 && (p = new ce(e.nodeDatum(m, f)), u.set(m, p)); let c = xt(e.targetId(h, f)), x = u.get(c); x === void 0 && (x = new ce(e.nodeDatum(c, f)), u.set(c, x)), (m !== c || !e.single) && (p.dataChildren.push(new le(x, h)), l.add(c)) } let d = e.decycle ? vt([...u.values()]) : po(u, l); return Nt(d, !e.decycle), d.length > 1 ? new te(d) : d[0] } function r(s) { if (s === void 0) return e.sourceId; { let { sourceId: u, ...l } = e; return fe({ ...l, sourceId: s }) } } t.sourceId = r; function n(s) { if (s === void 0) return e.targetId; { let { targetId: u, ...l } = e; return fe({ ...l, targetId: s }) } } t.targetId = n; function o(s) { if (s === void 0) return e.nodeDatum; { let { nodeDatum: u, ...l } = e; return fe({ ...l, nodeDatum: s }) } } t.nodeDatum = o; function a(s) { return s === void 0 ? e.single : fe({ ...e, single: s }) } t.single = a; function i(s) { return s === void 0 ? e.decycle : fe({ ...e, decycle: s }) } return t.decycle = i, t } function ho(e) { try { return typeof e[0] == "string" } catch { return !1 } } function mo(e) { if (ho(e)) return e[0]; throw new Error(`default source id expected datum[0] to be a string but got datum: ${e}`) } function go(e) { try { return typeof e[1] == "string" } catch { return !1 } } function xo(e) { if (go(e)) return e[1]; throw new Error(`default target id expected datum[1] to be a string but got datum: ${e}`) } function No(e) { return { id: e } } function ar(...e) { if (e.length) throw new Error(`got arguments to connect(${e}), but constructor takes no arguments. These were probably meant as data which should be called as connect()(...)`); return fe({ sourceId: mo, targetId: xo, nodeDatum: No, single: !1, decycle: !1 }) } function xe(e) { function t(...i) { if (!i.length) throw new Error("must pass in at least one node"); let s = new Map, u = []; function l(c) { let x = s.get(c); return x === void 0 && (x = new ce(c), s.set(c, x), u.push(x)), x } let d = i.map(l), f, h = 0; for (; f = u.pop();)f.dataChildren = (e.childrenData(f.data, h++) ?? []).map(([c, x]) => new le(l(c), x)); let m = new Set(d); for (let c of s.values()) for (let { child: x } of c.dataChildren) if (m.delete(x) && e.roots) throw new Error(F`node '${c.data}' pointed to a root`); let p = e.decycle ? vt([...s.values()]) : m.size ? [...m] : d; return Nt(p, !e.decycle), p.length > 1 ? new te(p) : p[0] } function r(i) { if (i === void 0) return e.children; { let { children: s, childrenData: u, ...l } = e; return xe({ ...l, children: i, childrenData: sr(i) }) } } t.children = r; function n(i) { if (i === void 0) return e.childrenData; { let { children: s, childrenData: u, ...l } = e; return xe({ ...l, children: vo(i), childrenData: i }) } } t.childrenData = n; function o(i) { return i === void 0 ? e.roots : xe({ ...e, roots: i }) } t.roots = o; function a(i) { return i === void 0 ? e.decycle : xe({ ...e, decycle: i }) } return t.decycle = a, t } function sr(e) { function t(r, n) { return (e(r, n) ?? []).map(o => [o, void 0]) } return t.wrapped = e, t } function vo(e) { function t(r, n) { return (e(r, n) ?? []).map(([o]) => o) } return t.wrapped = e, t } function yo(e) { try { let t = e.children; return t === void 0 || t instanceof Array } catch { return !1 } } function or(e) { if (yo(e)) return e.children; throw new Error(F`default children function expected datum to have a children field but got: ${e}`) } function Pe(...e) { if (e.length) throw new Error(`got arguments to hierarchy(${e}), but constructor takes no arguments. These were probably meant as data which should be called as hierarchy()(...)`); return xe({ children: or, childrenData: sr(or), roots: !0, decycle: !1 }) } function Ne(e) { function t(i) { if (!i.length) throw new Error("can't stratify empty data"); let s = new Map; for (let [d, f] of i.entries()) { let h = xt(e.id(f, d)), m = e.parentData(f, d) ?? [], p = new ce(f); if (s.has(h)) throw new Error(`found a duplicate id: ${r}`); s.set(h, [p, m]) } let u = []; for (let [d, f] of s.values()) { for (let [h, m] of f) { let p = s.get(h); if (!p) throw new Error(`missing id: ${h}`); let [c] = p; c.dataChildren.push(new le(d, m)) } f.length || u.push(d) } let l = e.decycle ? vt([...P(s.values(), ([d]) => d)]) : u; return Nt(l, !e.decycle), l.length > 1 ? new te(l) : l[0] } function r(i) { if (i === void 0) return e.id; { let { id: s, ...u } = e; return Ne({ ...u, id: i }) } } t.id = r; function n(i) { if (i === void 0) return e.parentData; { let { parentIds: s, parentData: u, ...l } = e; return Ne({ ...l, parentIds: bo(i), parentData: i }) } } t.parentData = n; function o(i) { if (i === void 0) return e.parentIds; { let { parentIds: s, parentData: u, ...l } = e; return Ne({ ...l, parentIds: i, parentData: ur(i) }) } } t.parentIds = o; function a(i) { return i === void 0 ? e.decycle : Ne({ ...e, decycle: i }) } return t.decycle = a, t } function ur(e) { function t(r, n) { return (e(r, n) ?? []).map(o => [o, void 0]) } return t.wrapped = e, t } function bo(e) { function t(r, n) { return (e(r, n) ?? []).map(([o]) => o) } return t.wrapped = e, t } function Oo(e) { try { return typeof e.id == "string" } catch { return !1 } } function wo(e) { if (Oo(e)) return e.id; throw new Error(F`default id function expected datum to have an id field but got '${e}'`) } function Do(e) { try { let t = e.parentIds; return t === void 0 || t instanceof Array && t.every(r => typeof r == "string") } catch { return !1 } } function ir(e) { if (Do(e)) return e.parentIds; throw new Error(`default parentIds function expected datum to have a parentIds field but got: ${e}`) } function dr(...e) { if (e.length) throw new Error(`got arguments to stratify(${e}), but constructor takes no arguments. These were probably meant as data which should be called as stratify()(...)`); return Ne({ id: wo, parentIds: ir, parentData: ur(ir), decycle: !1 }) } function U(e, t) { return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN } function Be(e, t) { return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN } function ve(e) { let t, r, n; e.length !== 2 ? (t = U, r = (s, u) => U(e(s), u), n = (s, u) => e(s) - u) : (t = e === U || e === Be ? e : So, r = e, n = e); function o(s, u, l = 0, d = s.length) { if (l < d) { if (t(u, u) !== 0) return d; do { let f = l + d >>> 1; r(s[f], u) < 0 ? l = f + 1 : d = f } while (l < d) } return l } function a(s, u, l = 0, d = s.length) { if (l < d) { if (t(u, u) !== 0) return d; do { let f = l + d >>> 1; r(s[f], u) <= 0 ? l = f + 1 : d = f } while (l < d) } return l } function i(s, u, l = 0, d = s.length) { let f = o(s, u, l, d - 1); return f > l && n(s[f - 1], u) > -n(s[f], u) ? f - 1 : f } return { left: o, center: i, right: a } } function So() { return 0 } function Re(e) { return e === null ? NaN : +e } function* fr(e, t) { if (t === void 0) for (let r of e) r != null && (r = +r) >= r && (yield r); else { let r = -1; for (let n of e) (n = t(n, ++r, e)) != null && (n = +n) >= n && (yield n) } } var lr = ve(U), Lo = lr.right, Co = lr.left, Io = ve(Re).center; function yt(e = U) { if (e === U) return _e; if (typeof e != "function") throw new TypeError("compare is not a function"); return (t, r) => { let n = e(t, r); return n || n === 0 ? n : (e(r, r) === 0) - (e(t, t) === 0) } } function _e(e, t) { return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0) } var pr = Array.prototype, Vo = pr.slice, La = pr.map; var ka = Math.sqrt(50), Ma = Math.sqrt(10), za = Math.sqrt(2); function ye(e, t) { let r; if (t === void 0) for (let n of e) n != null && (r < n || r === void 0 && n >= n) && (r = n); else { let n = -1; for (let o of e) (o = t(o, ++n, e)) != null && (r < o || r === void 0 && o >= o) && (r = o) } return r } function pe(e, t) { let r; if (t === void 0) for (let n of e) n != null && (r > n || r === void 0 && n >= n) && (r = n); else { let n = -1; for (let o of e) (o = t(o, ++n, e)) != null && (r > o || r === void 0 && o >= o) && (r = o) } return r } function Oe(e, t, r = 0, n = e.length - 1, o) { for (o = o === void 0 ? _e : yt(o); n > r;) { if (n - r > 600) { let u = n - r + 1, l = t - r + 1, d = Math.log(u), f = .5 * Math.exp(2 * d / 3), h = .5 * Math.sqrt(d * f * (u - f) / u) * (l - u / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(t - l * f / u + h)), p = Math.min(n, Math.floor(t + (u - l) * f / u + h)); Oe(e, t, m, p, o) } let a = e[t], i = r, s = n; for (be(e, r, t), o(e[n], a) > 0 && be(e, r, n); i < s;) { for (be(e, i, s), ++i, --s; o(e[i], a) < 0;)++i; for (; o(e[s], a) > 0;)--s } o(e[r], a) === 0 ? be(e, r, s) : (++s, be(e, s, n)), s <= t && (r = s + 1), t <= s && (n = s - 1) } return e } function be(e, t, r) { let n = e[t]; e[t] = e[r], e[r] = n } function we(e, t, r) { if (e = Float64Array.from(fr(e, r)), !!(n = e.length)) { if ((t = +t) <= 0 || n < 2) return pe(e); if (t >= 1) return ye(e); var n, o = (n - 1) * t, a = Math.floor(o), i = ye(Oe(e, a).subarray(0, a + 1)), s = pe(e.subarray(a + 1)); return i + (s - i) * (o - a) } } function he(e, t) { return we(e, .5, t) } function De(e, t = U) { let r, n = !1; if (t.length === 1) { let o; for (let a of e) { let i = t(a); (n ? U(i, o) < 0 : U(i, i) === 0) && (r = a, o = i, n = !0) } } else for (let o of e) (n ? t(o, r) < 0 : t(o, o) === 0) && (r = o, n = !0); return r } var Fo = mr(Math.random); function mr(e) { return function (r, n = 0, o = r.length) { let a = o - (n = +n); for (; a;) { let i = e() * a-- | 0, s = r[a + n]; r[a + n] = r[i + n], r[i + n] = s } return r } } var Ot = class { constructor(t) { this.uncompressed = t; this.indices = [] } getIndex(t, r) { let n = []; for (let [i, s] of this.indices.entries()) s <= t && n.push(i); this.uncompressed && n.push(this.indices.length); let o = r ?? 0, a = De(n, i => [Math.abs(o - i), i]) ?? this.indices.length; return this.setIndex(a, t), a } setIndex(t, r) { this.indices[t] = r } offset() { return 0 } }, wt = class { constructor(t) { this.uncompressed = t; this.posIndices = [0]; this.negIndices = [] } nextNeg() { return -this.negIndices.length - 1 } nextPos() { return this.posIndices.length } getIndex(t, r) { let n = []; for (let [s, u] of this.negIndices.entries()) u <= t && n.push(-s - 1); for (let [s, u] of this.posIndices.entries()) u <= t && n.push(s); this.uncompressed && (n.push(this.nextNeg()), n.push(this.nextPos())); let o = r ?? 0, a = this.negIndices.length < this.posIndices.length - 1 ? this.nextNeg() : this.nextPos(), i = De(n, s => [Math.abs(o - s), Math.abs(s), -s]) ?? a; return this.setIndex(i, t), i } setIndex(t, r) { t < 0 ? this.negIndices[-t - 1] = r : this.posIndices[t] = r } offset() { return this.negIndices.length } }; function Qo(e, t) { return t ? new wt(!e) : new Ot(!e) } function Jo(e, t) { for (let n of e) n.x = void 0; for (let n of e) { n.x === void 0 && (n.x = t.getIndex(n.y)); for (let o of [...n.ichildren()].sort((a, i) => i.y - a.y)) o.x === void 0 && (o.x = t.getIndex(n.y, n.x), t.setIndex(o.x, o.y)) } let r = t.offset(); for (let n of e) n.x += r } function Ko(e, t) { let r = new Map; for (let o of e) { o.x = void 0; for (let a of o.ichildren()) { let i = r.get(a); (i === void 0 || o.y < i.y) && r.set(a, o) } } for (let o of Ae(e)) { if (o.x === void 0) { let i = he(P(o.ichildren(), s => s.x)); o.x = t.getIndex(e.length - o.y, i) } let a = r.get(o); a !== void 0 && (a.x ??= o.x, t.setIndex(o.x, e.length - a.y)) } let n = t.offset(); for (let o of e) o.x += n } function $e(e, t, r) { function n(s) { let u = Qo(t, r); e ? Jo(s, u) : Ko(s, u) } function o(s) { return s === void 0 ? e : $e(s, t, r) } n.topDown = o; function a(s) { return s === void 0 ? t : $e(e, s, r) } n.compressed = a; function i(s) { return s === void 0 ? r : $e(e, t, s) } return n.bidirectional = i, n } function Ue(...e) { if (e.length) throw new Error(`got arguments to greedy(${e}), but constructor takes no arguments.`); return $e(!0, !0, !1) } function Yo(e) { for (let n of e) { if (n.x === void 0) throw new Error(F`coord didn't assign an x to node '${n}'`); if (n.x < 0) throw new Error(`coord assigned an x (${n.x}) less than 0`) } let t = new Set(e.map(n => n.x)); if (!Xt(t, new Set(P(t, (n, o) => o)))) { let n = [...t].join(", "); throw new Error(`didn't assign increasing positive integers for x coordinates: ${n}`) } let r = new Map; for (let [n, o] of e.entries()) { let a = r.get(o); if (a !== void 0) { for (let i of e.slice(a + 1, n)) if (i.x === o.x) throw new Error(F`node ${i} was assigned an overlapping lane with ${o}`) } for (let i of o.ichildren()) r.has(i) || r.set(i, n) } return t.size } function Se(e) { function t(i) { if (i.multidag()) throw new Error("grid layout doesn't make sense to apply to multidags, consider pruning the edges"); let { nodeWidth: s, nodeHeight: u, size: l, lane: d } = e, f = [...nr(i, e.rank)]; for (let [c, x] of f.entries()) x.y = c; d(f); let h = Yo(f); for (let c of f) c.x = (c.x + .5) * s, c.y = (c.y + .5) * u; let m = h * s, p = f.length * u; if (l !== null) { let [c, x] = l; for (let N of f) N.x *= c / m, N.y *= x / p; m = c, p = x } for (let { source: c, target: x, points: N } of i.ilinks()) N.length = 0, c.x !== x.x && N.push({ x: c.x, y: c.y }), N.push({ x: x.x, y: c.y }), N.push({ x: x.x, y: x.y }); return { width: m, height: p } } function r(i) { if (i === void 0) return e.lane; { let { lane: s, ...u } = e; return Se({ ...u, lane: i }) } } t.lane = r; function n(i) { if (i === void 0) return e.rank; { let { rank: s, ...u } = e; return Se({ ...u, rank: i }) } } t.rank = n; function o(i) { if (i === void 0) { let { nodeWidth: s, nodeHeight: u } = e; return [s, u] } else { let [s, u] = i; return Se({ ...e, nodeWidth: s, nodeHeight: u }) } } t.nodeSize = o; function a(i) { if (i !== void 0) return Se({ ...e, size: i }); if (e.size === null) return null; { let [s, u] = e.size; return [s, u] } } return t.size = a, t } function gr(...e) { if (e.length) throw new Error(`got arguments to grid(${e}), but constructor takes no arguments.`); return Se({ lane: Ue(), rank: () => { }, nodeWidth: 1, nodeHeight: 1, size: null }) } var rn = ze(tn()); function X(e, t, r, n, o = {}) { let { feasible: a, ...i } = rn.Solve.call({}, { optimize: e, opType: t, constraints: n, variables: r, ints: o }); if (!a) throw new Error("could not find a feasible simplex solution"); return i } function hi(e) { let t = [], r = new Set; for (let n of e) { if (!r.has(n)) { let o = t.findIndex(i => i <= n.y), a = o === -1 ? t.length : o; t[a] = n.y } for (let o of [...n.ichildren()].sort((a, i) => i.y - a.y)) if (!r.has(o)) { let a = t.findIndex(s => s <= n.y), i = a === -1 ? t.length : a; t[i] = o.y, r.add(o) } } return t.length } function Pt(e, t) { function r(a) { let i = {}, s = {}, u = {}, l = new Map(P(a, (m, p) => [m, p])), d = e ? hi(a) : a.length - 1; for (let m of a.keys()) i[m] = { opt: 0, [m]: 1 }, s[m] = { max: d - 1 }; let f = new Map; for (let [m, p] of a.entries()) { let c = f.get(p); if (c !== void 0) for (let [x, N] of a.slice(c + 1, m).entries()) { let v = x + c + 1, b = `${m}-${v}-above`; i[b] = { opt: 0, [b]: 1 }, s[b] = { max: 1 }, u[b] = 1; let y = `${b}-span`; i[m][y] = 1, i[v][y] = -1, i[b][y] = -d, s[y] = { min: 1 - d, max: -1 }; for (let w of N.ichildren()) { if (w === p) continue; let D = l.get(w), L = `${b}-${D}-cross`; i[L] = { opt: 1, [L]: 1 }, s[L] = { max: 1 }, u[L] = 1; let O = `${L}-left`; i[m][O] = -1, i[D][O] = 1, i[b][O] = d, i[L][O] = -d, s[O] = { max: d }; let S = `${L}-right`; i[m][S] = -1, i[D][S] = 1, i[b][S] = d, i[L][S] = d, s[S] = { min: 0 } } } for (let x of p.ichildren()) f.has(x) || f.set(x, m) } if (t) { let m = a.reduce((p, c) => p + c.children().length, 0); for (let [p, c] of a.entries()) for (let x of c.ichildren()) { let N = l.get(x), v = `${p}-${N}-dist`; i[v] = { opt: 1 / m }; let b = `${v}-upper`; i[p][b] = 1, i[N][b] = -1, i[v][b] = -d, s[b] = { max: 0 }; let y = `${v}-lower`; i[p][y] = 1, i[N][y] = -1, i[v][y] = d, s[y] = { min: 0 } } } let h = X("opt", "min", i, s, u); if (t || e) for (let [m, p] of a.entries()) p.x = h[m] ?? 0; else { let m = new Set; for (let c of a.keys()) m.add(h[c] ?? 0); let p = new Map(P([...m].sort(), (c, x) => [c, x])); for (let [c, x] of a.entries()) x.x = p.get(h[c] ?? 0) } } function n(a) { return a === void 0 ? e : Pt(a, t) } r.compressed = n; function o(a) { return a === void 0 ? t : Pt(e, a) } return r.dist = o, r } function nn(...e) { if (e.length) throw new Error(`got arguments to opt(${e}), but constructor takes no arguments.`); return Pt(!1, !0) } var bn = ze(yn()); function Di(e, t, r, n, o) { if (!t.length) return []; let a = [[0]], i = [0], s = [[0]], u = [0]; for (let f of e) { let h = [0]; h.push(...f), a.push(h) } i.push(...t), s.push(...t.map(() => [0])); for (let f of r) for (let [h, m] of f.entries()) s[h + 1].push(-m); u.push(...n.map(f => -f)); let { solution: l, message: d } = (0, bn.solveQP)(a, i, s, u, o); if (d.length) throw new Error(`quadratic program failed: ${d}`); return l.shift(), l } function Ye(e, t, r, n, o = 0) { t.pop(), e.pop(), e.forEach(i => i.pop()), r.forEach(i => i.pop()); let a = Di(e, t, r, n, o); return a.push(0), a } function On(e) { return new Map(e.flatMap(t => t).map((t, r) => [t, r])) } function Xe(e, t, r) { let n = 1 + Math.max(...t.values()), o = [], a = []; for (let u of e) for (let [l, d] of j(u)) { let f = t.get(l), h = t.get(d), m = new Array(n).fill(0); m[f] = 1, m[h] = -1, o.push(m), a.push(-(r(l) + r(d)) / 2) } let i = new Array(n).fill(0); return [[...new Array(n)].map(() => new Array(n).fill(0)), i, o, a] } function Rt(e, t, r, n) { e[r][r] += n, e[r][t] -= n, e[t][r] -= n, e[t][t] += n } function et(e, t, r, n, o) { e[n][n] += o, e[n][r] -= 2 * o, e[n][t] += o, e[r][n] -= 2 * o, e[r][r] += 4 * o, e[r][t] -= 2 * o, e[t][n] += o, e[t][r] -= 2 * o, e[t][t] += o } function tt(e, t, r, n) { let o = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY; for (let s of e) { let u = s[0], l = s[s.length - 1]; o = Math.min(o, n[r.get(u)] - t(u) / 2), a = Math.max(a, n[r.get(l)] + t(l) / 2) } let i = a - o; for (let s of e) for (let u of s) u.x = Math.min(Math.max(0, n[r.get(u)] - o), i); return i } function rt(e) { let t = Z(q(e, a => a)); function* r(a) { yield* a.ichildren(), yield* t.get(a) ?? [] } let n = 0, o = new Map; for (let a of q(e, i => i)) if (!o.has(a)) { for (let i of J(r, a)) o.set(i, n); n++ } return o } function nt(e, t) { let r = [], n = [], o = new Set; for (let a of e) { let i = new Set(a.map(s => t.get(s))); er(o, i) || r.push(n = []), n.push(a), o = i } return r } function Si(e) { let [t, r, n] = e; if (t <= 0 || r <= 0 || n <= 0) throw new Error("const accessors should return non-negative values"); let o = () => e; return o.value = e, o } function Li(e) { return "value" in e && typeof e.value == "object" && e.value.length === 3 && e.value.every(t => typeof t == "number") } function Ci(e, t) { if (Li(t)) { let [r, n, o] = t.value; if (r <= 0 || n <= 0 || o <= 0) throw new Error(`simplex weights must be positive, but got: ${r}, ${n}, ${o}`); return (i, s) => { switch (+("node" in i.data) + +("node" in s.data)) { case 0: return o; case 1: return n; case 2: return r; default: throw new Error("internal error") } } } else { let r = new Map; for (let o of q(e, a => a)) if ("node" in o.data) { let a = o.data.node, i = new Map; for (let s of a.ichildLinks()) { let { target: u } = s, l = t(s), [d, f, h] = l; if (d <= 0 || f <= 0 || h <= 0) throw new Error(`simplex weights must be positive, but got: ${d}, ${f}, ${h}`); i.set(u, l) } r.set(a, i) } return (o, a) => { if ("link" in o.data) { let { source: i, target: s } = o.data.link, [, u, l] = r.get(i).get(s); return "link" in a.data ? l : u } else if ("link" in a.data) { let { source: i, target: s } = a.data.link, [, u] = r.get(i).get(s); return u } else { let [i] = r.get(o.data.node).get(a.data.node); return i } } } } function wn(e) { function t(o, a) { let i = {}, s = {}, u = Ci(o, e.weight), l = new Map; for (let [p, c] of H(q(o, x => x))) { let x = p.toString(); l.set(c, x), i[x] = {} } function d(p) { return l.get(p) } for (let p of o) for (let [c, x] of j(p)) { let N = d(c), v = d(x), b = `layer ${N} -> ${v}`, y = (a(c) + a(x)) / 2; s[b] = { min: y }, i[N][b] = -1, i[v][b] = 1 } for (let p of q(o, c => c)) { let c = d(p); for (let x of p.ichildren()) { let N = d(x), v = `link ${c} -> ${N}`, b = `${v} parent`; s[b] = { min: 0 }; let y = `${v} child`; s[y] = { min: 0 }, i[c][b] = 1, i[c][y] = -1, i[N][b] = -1, i[N][y] = 1; let w = u(p, x); i[v] = { opt: w, [b]: 1, [y]: 1 } } } let f = X("opt", "min", i, s), h = 0, m = 0; for (let p of o) { for (let N of p) N.x = f[d(N)] ?? 0; let c = p[0]; h = Math.min(h, c.x - a(c) / 2); let x = p[p.length - 1]; m = Math.max(m, x.x + a(x) / 2) } for (let p of q(o, c => c)) p.x -= h; return m - h } function r(o, a) { let i = rt(o), s = nt(o, i), u = s.map(d => t(d, a)), l = Math.max(...u); if (l <= 0) throw new Error("must assign nonzero width to at least one node"); for (let [d, f] of s.entries()) { let h = (l - u[d]) / 2; for (let m of f) for (let p of m) p.x += h } return l } function n(o) { if (o === void 0) return e.weight; { let { weight: a, ...i } = e; return wn({ ...i, weight: o }) } } return r.weight = n, r } function ot(...e) { if (e.length) throw new Error(`got arguments to simplex(${e}), but constructor takes no arguments.`); return wn({ weight: Si([1, 2, 8]) }) } var _t = class { constructor() { this.mean = 0; this.count = 0 } add(t) { this.mean += (t - this.mean) / ++this.count } val() { return this.count ? this.mean : void 0 } }, Sn = () => new _t, Wt = class { constructor() { this.vals = [] } add(t) { this.vals.push(t) } val() { return he(this.vals) } }, Ln = () => new Wt, $t = class { constructor() { this.vals = [] } add(t) { this.vals.push(t) } val() { if (this.vals.sort((t, r) => t - r), this.vals.length !== 0) { if (this.vals.length === 2) return (this.vals[0] + this.vals[1]) / 2; if (this.vals.length % 2 === 0) { let t = this.vals.length / 2, r = this.vals[0], n = this.vals[t - 1], o = this.vals[t], a = this.vals[this.vals.length - 1], i = n - r, s = a - o; return (n * s + o * i) / (i + s) } else return this.vals[(this.vals.length - 1) / 2] } } }, Ut = () => new $t; function Ii(e, t) { let r = e(); for (let n of t) r.add(n); return r.val() } function Dn(e, t) { let r = new Map; for (let d of e) { let f = t.get(d); f !== void 0 && ie(r, f, d) } let n = [...r.entries()].sort(([d], [f]) => d - f).flatMap(([, d]) => d), o = new Map(e.map((d, f) => [d, f])), a = e.filter(d => t.get(d) === void 0), i = new Array(a.length).fill(null); function s(d, f, h, m) { if (f <= d) return; let p = Math.floor((d + f) / 2), c = a[p], x = o.get(c), N = 0, v = [N]; for (let y = h; y < m; ++y)N += o.get(n[y]) < x ? -1 : 1, v.push(N); let b = h + v.indexOf(Math.min(...v)); i[p] = b, s(d, p, h, b), s(p + 1, f, b, m) } s(0, a.length, 0, n.length), i.push(n.length + 1); let u = 0, l = 0; for (let [d, f] of n.entries()) { for (; i[l] == d;)e[u++] = a[l++]; e[u++] = f } for (; i[l] == n.length;)e[u++] = a[l++] } function Cn({ factory: e }) { function t(n, o, a) { if (a) { let i = new Map(o.map(u => [u, e()])); for (let [u, l] of n.entries()) for (let d of l.ichildren()) i.get(d).add(u); let s = new Map([...i.entries()].map(([u, l]) => [u, l.val()])); Dn(o, s) } else { let i = new Map(o.map((u, l) => [u, l])), s = new Map(n.map(u => { let l = Ii(e, P(u.ichildren(), d => i.get(d))); return [u, l] })); Dn(n, s) } } function r(n) { return n === void 0 ? e : Cn({ factory: n }) } return t.aggregator = r, t } function it(...e) { if (e.length) throw new Error(`got arguments to agg(${e}), but constructor takes no arguments.`); return Cn({ factory: Ut }) } function In(e, t) { let r = new Map, n = new Map(e.map((a, i) => [a, i])); function o(a, i) { let s = r.get(a)?.get(i); if (s !== void 0) return s; { let u = 0; for (let f of t(a)) for (let h of t(i)) u += Math.sign(n.get(f) - n.get(h)); let l = r.get(a); l === void 0 ? r.set(a, new Map([[i, u]])) : l.set(i, u); let d = r.get(i); return d === void 0 ? r.set(i, new Map([[a, -u]])) : d.set(a, -u), u } } return o } function ki(e, t) { let r = [[0, e.length]], n; for (; n = r.pop();) { let [o, a] = n; if (o >= a) continue; let i = 0, s = a; for (let u = o; u < a - 1; ++u) { let l = t(e[u], e[u + 1]); l > i && (i = l, s = u) } s !== a && ([e[s], e[s + 1]] = [e[s + 1], e[s]], r.push([o, s], [s + 2, a])) } } function Mi(e, t) { let r = new Array(e.length * (e.length - 1) / 2); for (; ;) { let n = 0; for (let u = 1; u < e.length; ++u) { let l = 0, d = n; for (let f = u - 1; f >= 0; --f)r[d] = l, l += t(e[f], e[u]), d -= e.length - f - 1; n += e.length - u } let o = 0, a = 0, i = 0, s = 0; for (let u = 0; u < e.length - 1; ++u) { let l = 0; for (let d = u + 1; d < e.length; ++d) { l += t(e[u], e[d]); let f = r[o++] + l; f > a && (a = f, i = u, s = d) } } if (a === 0) break;[e[i], e[s]] = [e[s], e[i]] } } function Gt({ baseOp: e, doScan: t }) { function r(a, i, s) { e(a, i, s); let u, l; if (s) { let d = Z(a); l = In(a, f => d.get(f) ?? []), u = i } else l = In(i, d => d.ichildren()), u = a; t ? Mi(u, l) : ki(u, l) } function n(a) { return a === void 0 ? e : Gt({ baseOp: a, doScan: t }) } r.base = n; function o(a) { return a === void 0 ? t : Gt({ baseOp: e, doScan: a }) } return r.scan = o, r } function at(...e) { if (e.length) throw new Error(`got arguments to greedy(${e}), but constructor takes no arguments.`); return Gt({ baseOp: () => { }, doScan: !1 }) } function zi(e) { if (e.value === void 0) throw new Error(F`node with data '${e.data}' did not get a defined value during layering`); if (e.value < 0) throw new Error(F`node with data '${e.data}' got an invalid (negative) value during layering: ${e.value}`); return e.value } function st(e) { let t = new Map(P(e, i => [i, { node: i, layer: zi(i) }])); for (let { source: i, target: s } of e.ilinks()) { let u = i.nchildLinksTo(s) > 1; if (u && i.value + 1 >= s.value) throw new Error(F`layering left child data '${s.data}' (${s.value}) whose layer was not two more than its parent data '${i.data}' (${i.value})`); if (!u && i.value >= s.value) throw new Error(F`layering left child data '${s.data}' (${s.value}) whose layer was not greater than its parent data '${i.data}' (${i.value})`) } function r(i) { let s = i.layer + 1; return ("node" in i ? i.node.childLinks() : [i.link]).map(l => { let d = t.get(l.target); return d.layer === s ? d : { link: l, layer: s } }) } let o = Pe().children(r)(...P(e.iroots(), i => t.get(i))); ge(!o.multidag()); let a = []; for (let i of o) (a[i.data.layer] || (a[i.data.layer] = [])).push(i); if (!a[0] || !a[0].length) throw new Error("no nodes were assigned to layer 0"); for (let i of a) ge(i && i.length); return a } function ut(e) { for (let t of e) for (let r of t) { if ("link" in r.data) continue; r.data.node.x = r.x, r.data.node.y = r.y; let n = new Map(P(r.data.node.ichildLinks(), ({ points: o, target: a }) => [a, o])); for (let o of r.ichildren()) { let a = [{ x: r.x, y: r.y }]; for (; "link" in o.data;)a.push({ x: o.x, y: o.y }), [o] = o.ichildren(); a.push({ x: o.x, y: o.y }); let i = n.get(o.data.node); i.splice(0, i.length, ...a) } } } function kn(e, t) { for (let r of e) { let n = 0; for (let o of r) { if (o.x === void 0) throw new Error(F`coord didn't assign an x to node '${o}'`); if (o.x < n) throw new Error(F`coord assigned an x (${o.x}) smaller than a previous node in the layer '${o}'`); n = o.x } if (n > t) throw new Error(`coord assigned an x (${n}) greater than width (${t})`) } } function Mn(e, t, r) { for (let n of e) for (let o of n) o.x *= t, o.y *= r } function dt(e) { let t = 0; for (let [r, n] of j(e)) { let o = new Map(n.map((a, i) => [a, i])); for (let [a, i] of r.entries()) for (let s of r.slice(a + 1)) for (let u of i.ichildren()) for (let l of s.ichildren()) u !== l && o.get(u) > o.get(l) && t++ } return t } function zn(e) { function t(n) { let o; if (e.topDown) o = J(a => a.ichildren(), ...q(Ae(n), a => a)); else { let a = Z(q(n, i => i)); o = J(i => a.get(i) ?? [], ...q(n, i => i)) } for (let a of n) a.splice(0); for (let a of o) n[a.data.layer].push(a) } function r(n) { return n === void 0 ? e.topDown : zn({ topDown: n }) } return t.topDown = r, t } function ke(...e) { if (e.length) throw new Error(`got arguments to dfs(${e}), but constructor takes no arguments.`); return zn({ topDown: !0 }) } function ft(e) { function t(a) { let i = a.slice().reverse(), s = a.map(l => l.slice()), u = dt(s); for (let l of e.inits) { l(a); let d = !0; for (let f = 0; f < e.passes && d; ++f) { d = !1; for (let [p, c] of j(a)) { let x = c.slice(); e.order(p, c, !0), c.some((N, v) => x[v] !== N) && (d = !0) } let h = dt(a); h < u && (u = h, s = a.map(p => p.slice())); for (let [p, c] of j(i)) { let x = c.slice(); e.order(c, p, !1), c.some((N, v) => x[v] !== N) && (d = !0) } let m = dt(a); m < u && (u = m, s = a.map(p => p.slice())) } } a.splice(0, a.length, ...s) } function r(a) { if (a === void 0) return e.order; { let { order: i, ...s } = e; return ft({ ...s, order: a }) } } t.order = r; function n(a) { if (a === void 0) return [...e.inits]; if (a.length) { let { inits: i, ...s } = e; return ft({ ...s, inits: [...a] }) } else throw new Error("inits must be a non-empty array, maybe you intended the singleton noop: `[() => undefined]`") } t.inits = n; function o(a) { if (a === void 0) return e.passes; if (a <= 0) throw new Error("number of passes must be positive"); return ft({ ...e, passes: a }) } return t.passes = o, t } function lt(...e) { if (e.length) throw new Error(`got arguments to twoLayer(${e}), but constructor takes no arguments.`); return ft({ order: at().base(it()), inits: [ke(), ke().topDown(!1)], passes: 24 }) } function qt(e) { function t(o) { let a = {}, i = {}, s = {}, u = new Map(P(o, (x, N) => [x, N.toString()])); function l(x) { return u.get(x) } function d(x) { return a[l(x)] } function f(x, N, v, b = 1) { let y = d(N), w = d(v), D = `${x}: ${l(N)} -> ${l(v)}`; i[D] = { min: b }, y[D] = -1, w[D] = 1 } function h(x, N, v) { f(`${x} before`, N, v, 0), f(`${x} after`, v, N, 0) } let m = [], p = new Map; for (let x of o) { let N = l(x); s[N] = 1, a[N] = { opt: 0 }; let v = e.rank(x); v !== void 0 && m.push([v, x]); let b = e.group(x); if (b !== void 0) { let y = p.get(b); y ? y.push(x) : p.set(b, [x]) } } for (let x of o) for (let [N, v] of x.ichildrenCounts()) f("link", x, N, v > 1 ? 2 : 1), d(x).opt += v, d(N).opt -= v; let c = m.sort(([x], [N]) => x - N); for (let [[x, N], [v, b]] of j(c)) x < v ? f("rank", N, b) : h("rank", N, b); for (let x of p.values()) for (let [N, v] of j(x)) h("group", N, v); try { let x = X("opt", "max", a, i, s); for (let N of o) N.value = x[l(N)] ?? 0 } catch { throw ge(m.length || p.size), new Error("could not find a feasible simplex layout, check that rank or group accessors are not ill-defined") } } function r(o) { if (o === void 0) return e.rank; { let { rank: a, ...i } = e; return qt({ ...i, rank: o }) } } t.rank = r; function n(o) { if (o === void 0) return e.group; { let { group: a, ...i } = e; return qt({ ...i, group: o }) } } return t.group = n, t } function An() { } function ct(...e) { if (e.length) throw new Error(`got arguments to simplex(${e}), but constructor takes no arguments.`); return qt({ rank: An, group: An }) } function En(e) { let t = e(); function r(n) { return "node" in n.data ? e(n.data.node) : t } return r.wrapped = e, r } function Ai(e, t = !0) { let r = new Map; function n(i) { let s = r.get(i); if (s === void 0) { s = e(i); let [u, l] = s; if (t && (u < 0 || l < 0)) throw new Error(F`all node sizes must be non-negative, but got width ${u} and height ${l} for node '${i}'`); r.set(i, s) } return s } return [i => n(i)[0], i => n(i)[1]] } function Ft(e, t) { let r = 0; for (let n of e) { let o = Math.max(...n.map(t)); for (let a of n) a.y = r + o / 2; r += o } return r } function se(e) { function t(u) { e.layering(u); let l = st(u), [d, f] = Ai(e.sugiNodeSize), h = Ft(l, f); if (h <= 0) throw new Error("at least one node must have positive height, but total height was zero"); e.decross(l); let m = e.coord(l, d); if (kn(l, m), e.size !== null) { let [p, c] = e.size; Mn(l, p / m, c / h), m = p, h = c } return ut(l), { width: m, height: h } } function r(u) { if (u === void 0) return e.layering; { let { layering: l, ...d } = e; return se({ ...d, layering: u }) } } t.layering = r; function n(u) { if (u === void 0) return e.decross; { let { decross: l, ...d } = e; return se({ ...d, decross: u }) } } t.decross = n; function o(u) { if (u === void 0) return e.coord; { let { coord: l, ...d } = e; return se({ ...d, coord: u }) } } t.coord = o; function a(u) { return u !== void 0 ? se({ ...e, size: u }) : e.size } t.size = a; function i(u) { if (u !== void 0) { let { nodeSize: l, sugiNodeSize: d, ...f } = e; return se({ ...f, nodeSize: u, sugiNodeSize: En(u) }) } else return e.nodeSize } t.nodeSize = i; function s(u) { if (u !== void 0) { let { sugiNodeSize: l, nodeSize: d, ...f } = e; return se({ ...f, sugiNodeSize: u, nodeSize: null }) } else return e.sugiNodeSize } return t.sugiNodeSize = s, t } function Tn(e) { return [+(e !== void 0), 1] } function Vn(...e) { if (e.length) throw new Error(`got arguments to sugiyama(${e}), but constructor takes no arguments.`); return se({ layering: ct(), decross: lt(), coord: ot(), size: null, nodeSize: Tn, sugiNodeSize: En(Tn) }) } function Pn(...e) { if (e.length) throw new Error(`got arguments to center(${e}), but constructor takes no arguments.`); function t(r, n) { let o = r.map(i => { let s = 0; for (let u of i) { let l = n(u); u.x = s + l / 2, s += l } return s }), a = Math.max(...o); if (a <= 0) throw new Error("must assign nonzero width to at least one node"); for (let [i, s] of r.entries()) { let u = o[i], l = (a - u) / 2; for (let d of s) d.x += l } return a } return t } function Bn(...e) { if (e.length) throw new Error(`got arguments to greedy(${e}), but constructor takes no arguments.`); function t(r, n) { let o = Ti, a = new Map; for (let f of r) for (let h of f) a.set(h, h.nchildren() + ("node" in h.data ? 0 : -3)); for (let f of r) for (let h of f) for (let m of h.ichildren()) a.set(m, a.get(m) + 1); let [i, ...s] = r, u = 0, l = 0; for (let f of i) { let h = n(f); f.x = l + h / 2, l += h } for (let f of s) { o(i, f); let h = f.map((m, p) => [p, m]).sort(([m, p], [c, x]) => { let N = a.get(p), v = a.get(x); return N === v ? m - c : v - N }); for (let [m, p] of h) { let c = n(p), x = p.x + c / 2; for (let v of f.slice(m + 1)) { let b = n(v) / 2; x = (v.x = Math.max(v.x, x + b)) + b } l = Math.max(l, x); let N = p.x - c / 2; for (let v of f.slice(0, m).reverse()) { let b = n(v) / 2; N = (v.x = Math.min(v.x, N - b)) - b } u = Math.min(u, N) } i = f } for (let f of r) for (let h of f) h.x -= u; let d = l - u; if (d <= 0) throw new Error("must assign nonzero width to at least one node"); return d } return t } function Ti(e, t) { for (let n of t) n.x = 0; let r = new Map; for (let n of e) for (let o of n.ichildren()) { let a = (r.get(o) || 0) + 1; r.set(o, a), o.x += (n.x - o.x) / a } } function oe(e) { if (e < 0) throw new Error("const accessors should return non-negative values"); let t = () => e; return t.value = e, t } function ue(e) { return "value" in e && typeof e.value == "number" } function Ei(e, t) { if (ue(e)) { let r = e.value; for (let n of q(t, o => o)) if ("node" in n.data) { let o = n.data.node; for (let a of o.ichildLinks()) if (e(a) !== r) throw new Error("passed in a vertWeak accessor with a `value` property that wasn't a const accessor") } return () => r } else { let r = new Map; for (let n of q(t, o => o)) if ("node" in n.data) { let o = n.data.node, a = new Map(P(o.ichildLinks(), i => [i.target, e(i)])); r.set(o, a) } return (n, o) => r.get(n).get(o) } } function Rn(e) { if (ue(e)) return e; { let t = new Map; return r => { let { source: n, target: o } = r, a = t.get(n); a === void 0 && (a = new Map, t.set(n, a)); let i = a.get(o); if (i === void 0) { let s = e(r); if (s < 0) throw new Error("link weights must be non-negative"); return a.set(o, s), s } else return i } } } function Vi(e) { if (ue(e)) return e; { let t = new Map; return r => { let n = t.get(r); if (n === void 0) { let o = e(r); if (o < 0) throw new Error("node weights must be non-negative"); return t.set(r, o), o } else return n } } } function ne(e) { function t(d, f, h) { let { comp: m } = e, p = On(d), [c, x, N, v] = Xe(d, p, f), b = Ei(e.vertWeak, d), y = Rn(e.vertStrong), w = Rn(e.linkCurve), D = Vi(e.nodeCurve); for (let S of q(d, C => C)) { let C = p.get(S), k = S.data, M = "node" in k ? k.node : k.link.source; for (let A of S.ichildren()) { let E = p.get(A), T = A.data, z = "node" in T ? T.node : T.link.target, W = "node" in k ? b(M, z) : y(k.link), G = "node" in T ? b(M, z) : y(T.link), $ = "node" in T ? D(T.node) : w(T.link); Rt(c, C, E, W + G); for (let B of A.ichildren()) { let ee = p.get(B); et(c, C, E, ee, $) } } } let L = new Map; for (let S of d) for (let [C, k] of j(S)) { let M = h.get(C), A = h.get(k); if (M !== A) { let E = L.get(M); E === void 0 ? L.set(M, new Set([A])) : E.add(A) } } let O = new Map; for (let [S, C] of L.entries()) { let k = new Set; for (let M of C) { let A = J(T => L.get(T) ?? [], M); de(A, T => T === S) || k.add(M) } O.set(S, k) } for (let S of d) for (let [C, k] of j(S)) { let M = h.get(C), A = h.get(k); M !== A && O.get(M)?.has(A) && Rt(c, p.get(C), p.get(k), m) } try { let S = Ye(c, x, N, v); return tt(d, f, p, S) } catch (S) { throw S instanceof Error && S.message === "quadratic program failed: matrix D in quadratic function is not positive definite!" ? new Error("quad objective wasn't well defined, this happens when too many of the weights were set to zero (or really small). Try changing the weight accessors to return nonzero values in more instances.") : S } } function r(d, f) { let h = rt(d), m = nt(d, h), p = m.map(x => t(x, f, h)), c = Math.max(...p); if (c <= 0) throw new Error("must assign nonzero width to at least one node"); for (let [x, N] of m.entries()) { let v = (c - p[x]) / 2; for (let b of N) for (let y of b) y.x += v } return c } function n(d) { if (d === void 0) { let { vertWeak: f, vertStrong: h } = e; return ue(f) && ue(h) ? [f.value, h.value] : null } else { let [f, h] = d; if (f < 0 || h < 0) throw new Error(`weights must be non-negative, but were ${f} and ${h}`); { let { vertWeak: m, vertStrong: p, ...c } = e; return ne({ ...c, vertWeak: oe(f), vertStrong: oe(h) }) } } } r.vertical = n; function o(d) { if (d === void 0) return e.vertWeak; { let { vertWeak: f, ...h } = e; return ne({ ...h, vertWeak: d }) } } r.vertWeak = o; function a(d) { if (d === void 0) return e.vertStrong; { let { vertStrong: f, ...h } = e; return ne({ ...h, vertStrong: d }) } } r.vertStrong = a; function i(d) { if (d === void 0) { let { linkCurve: f, nodeCurve: h } = e; return ue(f) && ue(h) ? [h.value, f.value] : null } else { let [f, h] = d; if (f < 0 || h < 0) throw new Error(`weights must be non-negative, but were ${f} and ${h}`); { let { linkCurve: m, nodeCurve: p, ...c } = e; return ne({ ...c, linkCurve: oe(h), nodeCurve: oe(f) }) } } } r.curve = i; function s(d) { if (d === void 0) return e.linkCurve; { let { linkCurve: f, ...h } = e; return ne({ ...h, linkCurve: d }) } } r.linkCurve = s; function u(d) { if (d === void 0) return e.nodeCurve; { let { nodeCurve: f, ...h } = e; return ne({ ...h, nodeCurve: d }) } } r.nodeCurve = u; function l(d) { if (d === void 0) return e.comp; if (d <= 0) throw new Error(`weight must be positive, but was ${d}`); return ne({ ...e, comp: d }) } return r.component = l, r } function _n(...e) { if (e.length) throw new Error(`got arguments to quad(${e}), but constructor takes no arguments.`); return ne({ vertWeak: oe(1), vertStrong: oe(0), linkCurve: oe(1), nodeCurve: oe(0), comp: 1 }) } function Wn(...e) { if (e.length) throw new Error(`got arguments to topological(${e}), but constructor takes no arguments.`); function t(r, n) { for (let h of r) if (h.reduce((p, c) => p + +("node" in c.data), 0) !== 1) throw new Error("topological() only works with a topological layering"); let o = new Map, a = 0; for (let h of r) for (let m of h) "link" in m.data && o.set(m, a++); for (let h of r) for (let m of h) "node" in m.data && o.set(m, a); let [i, s, u, l] = Xe(r, o, n); for (let h of r) for (let m of h) { let p = o.get(m); for (let c of m.ichildren()) { let x = o.get(c); if ("link" in c.data) for (let N of c.ichildren()) { let v = o.get(N); et(i, p, x, v, 1) } } } let d = Ye(i, s, u, l), f = tt(r, n, o, d); if (f <= 0) throw new Error("must assign nonzero width to at least one node"); return f } return t } function jt(e) { function t(o) { let a = o.reduce((y, w) => y + w.length * Math.max(w.length - 1, 0) / 2, 0), i = o.reduce((y, w) => y + w.reduce((D, L) => D + L.nchildren(), 0), 0); if (e.large !== "large" && a > 1200) throw new Error('size of dag to decrossOpt is too large and will likely crash instead of complete, enable "large" graphs to run anyway'); if (e.large !== "large" && e.large !== "medium" && (a > 400 || i > 100)) throw new Error('size of dag to decrossOpt is too large and will likely not complete, enable "medium" graphs to run anyway'); let s = []; for (let [y, w] of j(o)) { let D = new Set(y.flatMap(M => M.children())), L = w.filter(M => !D.has(M)), O = y.map(M => M.children()).filter(M => M.length > 1); s.push([L, O]); let S = y.filter(M => !M.nchildren()), k = [...Z(y).values()]; s.push([S, k]) } let u = s.reduce((y, [w, D]) => D.reduce((L, O) => L + O.length * O.length, 0) * w.length, 0) / 4, l = 1 / (u + 1), d = l / (a + 1), f = {}, h = {}, m = {}, p = new Map; { let y = 0; for (let w of o) for (let D of w) p.set(D, y++) } function c(...y) { return y.map(w => p.get(w)).sort((w, D) => w - D).join(" => ") } function x(y) { for (let [w, D] of y.slice(0, y.length - 1).entries()) for (let L of y.slice(w + 1)) { let O = c(D, L); m[O] = 1, h[O] = { max: 1 }, f[O] = { opt: -d, [O]: 1 } } for (let [w, D] of y.slice(0, y.length - 1).entries()) for (let [L, O] of y.slice(w + 1).entries()) for (let S of y.slice(w + L + 2)) { let C = c(D, O), k = c(D, S), M = c(O, S), A = c(D, O, S), E = A + "+"; h[E] = { max: 1 }, f[C][E] = 1, f[k][E] = -1, f[M][E] = 1; let T = A + "-"; h[T] = { min: 0 }, f[C][T] = 1, f[k][T] = -1, f[M][T] = 1 } } function N(y) { for (let [w, D] of y.slice(0, y.length - 1).entries()) for (let L of y.slice(w + 1)) { let O = c(D, L); for (let S of D.ichildren()) for (let C of L.ichildren()) { if (S === C) continue; let k = c(S, C), M = `slack (${O}) (${k})`, A = `${M} +`, E = `${M} -`; f[M] = { opt: 1, [A]: 1, [E]: 1 }; let T = Math.sign(p.get(S) - p.get(C)), z = Math.max(T, 0); h[A] = { min: z }, f[O][A] = 1, f[k][A] = T, h[E] = { min: -z }, f[O][E] = -1, f[k][E] = -T } } } function v(y, w) { for (let D of y) for (let L of w) for (let [O, S] of L.entries()) for (let C of L.slice(O + 1)) { let M = `dist ${[S, D, C].map(z => p.get(z)).join(" => ")}`, A = `${M} normal`, E = `${M} reversed`; f[M] = { opt: l, [A]: 1, [E]: 1 }; let T = 0; for (let [z, W] of [[S, D], [S, C], [D, C]]) { let G = c(z, W), $ = Math.sign(p.get(z) - p.get(W)); T += +($ > 0), f[G][A] = -$, f[G][E] = $ } h[A] = { min: 1 - T }, h[E] = { min: T - 2 } } } for (let y of o) x(y); for (let y of o.slice(0, o.length - 1)) N(y); if (e.dist) for (let [y, w] of s) v(y, w); let b = X("opt", "min", f, h, m); for (let y of o) y.sort((w, D) => b[c(w, D)] || -1) } function r(o) { return o === void 0 ? e.large : jt({ ...e, large: o }) } t.large = r; function n(o) { return o === void 0 ? e.dist : jt({ ...e, dist: o }) } return t.dist = n, t } function $n(...e) { if (e.length) throw new Error(`got arguments to opt(${e}), but constructor takes no arguments.`); return jt({ large: "small", dist: !1 }) } var Un = ze(mt()); function Gn(e) { function t(n) { let o = e.width || Math.floor(Math.sqrt(n.size() + .5)); function a([m], [p]) { for (let [c, x] of m.entries()) { let N = p[c]; if (N === void 0) return !1; if (x < N) return !0; if (N < x) return !1 } return !0 } let i = new Un.default(a), s = new Map(P(n, m => [m, []])), u = Ve(n); for (let m of n.iroots()) i.add([[], m]); let l = 0, d = 0, f = 0, h; for (; h = i.poll();) { let [, m] = h, p = u.get(m)?.reduce((c, [x, N]) => Math.max(c, x.value + +(N > 1)), 0); f < o && (p === void 0 || p < d) ? (m.value = d, f++) : (m.value = d = Math.max(p ?? 0, d) + 1, f = 1); for (let c of m.ichildren()) { let x = s.get(c); x.push(l), x.length === u.get(c).length && i.add([x.reverse(), c]) } l++ } } function r(n) { if (n === void 0) return e.width; if (n < 0) throw new Error(`width must be non-negative: ${n}`); return Gn({ ...e, width: n }) } return t.width = r, t } function qn(...e) { if (e.length) throw new Error(`got arguments to coffmanGraham(${e}), but constructor takes no arguments.`); return Gn({ width: 0 }) } function Fn(e) { function t(n) { if (e.topDown) { let o = Ve(n); for (let a of n.idescendants("before")) a.value = Math.max(0, ...P(o.get(a) ?? [], ([i, s]) => i.value + (s > 1 ? 2 : 1))) } else { let o = 0; for (let a of n.idescendants("after")) a.value = Math.max(0, ...P(a.ichildrenCounts(), ([i, s]) => i.value + (s > 1 ? 2 : 1))), o = Math.max(o, a.value); for (let a of n) a.value = o - a.value } } function r(n) { return n === void 0 ? e.topDown : Fn({ ...e, topDown: n }) } return t.topDown = r, t } function jn(...e) { if (e.length) throw new Error(`got arguments to longestPath(${e}), but constructor takes no arguments.`); return Fn({ topDown: !0 }) } function Hn(...e) { if (e.length) throw new Error(`got arguments to topological(${e}), but constructor takes no arguments.`); function t(r) { let n = 0, o; for (let a of r.idescendants("before")) o !== void 0 && o.nchildLinksTo(a) > 1 && ++n, a.value = n++, o = a } return t } function Ht(e) { function t(o, a, i) { let s = i ? a : o, u = s.length * Math.max(s.length - 1, 0) / 2, l = o.reduce((L, O) => L + O.nchildren(), 0); if (e.large !== "large" && u > 1200) throw new Error('size of dag to twolayerOpt is too large and will likely crash, enable "large" dags to run anyway'); if (e.large !== "large" && e.large !== "medium" && (u > 400 || l > 100)) throw new Error('size of dag to twolayerOpt is too large and will likely not finish, enable "medium" dags to run anyway'); let d = {}, f = {}, h = {}, m = new Map(s.map((L, O) => [L, O])); function p(...L) { return L.map(O => m.get(O)).sort((O, S) => O - S).join(" => ") } let c, x; if (i) { let L = new Set(o.flatMap(O => O.children())); c = a.filter(O => !L.has(O)), x = o.map(O => O.children()).filter(O => O.length > 1) } else c = o.filter(O => !O.nchildren()), x = [...Z(o).values()]; let v = x.reduce((L, O) => L + O.length * O.length, 0) * c.length / 4, b = 1 / (v + 1), y = b / (u + 1), w = new Map(a.map((L, O) => [L, O])); for (let [L, O] of s.slice(0, s.length - 1).entries()) for (let S of s.slice(L + 1)) { let C = p(O, S); h[C] = 1, f[C] = { max: 1 }, d[C] = { opt: -y, [C]: 1 } } for (let [L, O] of s.slice(0, s.length - 1).entries()) for (let [S, C] of s.slice(L + 1).entries()) for (let k of s.slice(L + S + 2)) { let M = p(O, C), A = p(O, k), E = p(C, k), T = p(O, C, k), z = T + "+"; f[z] = { max: 1 }, d[M][z] = 1, d[A][z] = -1, d[E][z] = 1; let W = T + "-"; f[W] = { min: 0 }, d[M][W] = 1, d[A][W] = -1, d[E][W] = 1 } for (let [L, O] of o.slice(0, o.length - 1).entries()) for (let S of o.slice(L + 1)) for (let C of O.ichildren()) for (let k of S.ichildren()) { if (C === k) continue; let M = i ? p(C, k) : p(O, S); d[M].opt += Math.sign(w.get(C) - w.get(k)) } if (e.dist) for (let L of c) for (let O of x) for (let [S, C] of O.entries()) for (let k of O.slice(S + 1)) { let A = `dist ${[C, L, k].map(W => m.get(W)).join(" => ")}`, E = `${A} normal`, T = `${A} reversed`; d[A] = { opt: b, [E]: 1, [T]: 1 }; let z = 0; for (let [W, G] of [[C, L], [C, k], [L, k]]) { let $ = p(W, G), B = Math.sign(m.get(W) - m.get(G)); z += +(B > 0), d[$][E] = -B, d[$][T] = B } f[E] = { min: 1 - z }, f[T] = { min: z - 2 } } let D = X("opt", "min", d, f, h); s.sort((L, O) => D[p(L, O)] || -1) } function r(o) { return o === void 0 ? e.large : Ht({ ...e, large: o }) } t.large = r; function n(o) { return o === void 0 ? e.dist : Ht({ ...e, dist: o }) } return t.dist = n, t } function Zn(...e) { if (e.length) throw new Error(`got arguments to opt(${e}), but constructor takes no arguments.`); return Ht({ large: "small", dist: !1 }) } function Qn(e, t) { let r = e.findIndex(n => n <= t); return r >= 0 ? r : e.length } function Jn(e) { let t = new Map(e), r = []; for (let [i, [s, u]] of e.entries()) { let l = !1, d = e[i + 1]?.[0]; for (let [f, { target: h }] of H(s.ichildLinks())) { let m = t.get(h); d === h && !l ? l = !0 : r.push([u, m, s, f]) } } r.sort(([i, s], [u, l]) => s === l ? u - i : s - l); let n = new Map, o = [], a = []; for (let [i, s, u, l] of r) { let d = n.get(u); d === void 0 && (d = [], n.set(u, d)); let f = Qn(a, i), h = Qn(o, i); f < h ? (d[l] = -f - 1, a[f] = s - 1) : (d[l] = h + 1, o[h] = s - 1) } return n } function Zt(e, t, r, n) { function o(s) { let u = [], l = 0, d; for (let N of s.idescendants("before")) d !== void 0 && d.nchildLinksTo(N) > 1 && ++l, u.push([N, l++]), d = N; let f = Jn(u), h = 0, m = 0; for (let N of f.values()) for (let v of N) v !== void 0 && (h = Math.min(h, v), m = Math.max(m, v)); let p = -h * r + e / 2; for (let [N, v] of u) N.x = p, N.y = (v + .5) * t; for (let N of s) { let v = f.get(N) ?? []; for (let [b, { target: y, points: w }] of H(N.ichildLinks())) { w.length = 0, w.push({ x: N.x, y: N.y }); let D = v[b]; if (D !== void 0) { let L = (D - h + .5) * r + (D > 0 ? e - r : 0), O = N.y + t, S = y.y - t; S - O > t / 2 ? w.push({ x: L, y: O }, { x: L, y: S }) : w.push({ x: L, y: O }) } w.push({ x: y.x, y: y.y }) } } let c = (m - h) * r + e, x = l * t; if (n === null) return { width: c, height: x }; { let [N, v] = n; for (let [b] of u) b.x *= N / c, b.y *= v / x; for (let { points: b } of s.ilinks()) { let y = b.map(({ x: w, y: D }) => ({ x: w * N / c, y: D * v / x })); b.splice(0, b.length, ...y) } return { width: N, height: v } } } function a(s) { if (s === void 0) return [e, t, r]; { let [u, l, d] = s; return Zt(u, l, d, n) } } o.nodeSize = a; function i(s) { if (s !== void 0) return Zt(e, t, r, s); if (n === null) return n; { let [u, l] = n; return [u, l] } } return o.size = i, o } function Kn(...e) { if (e.length) throw new Error(`got arguments to zherebko(${e}), but constructor takes no arguments.`); return Zt(1, 1, 1, null) } return uo(Pi);
        })();
        return d3;
    })());
}
